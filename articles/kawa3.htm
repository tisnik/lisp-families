<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Zpracování vektorů, matic a N-rozměrných polí v programovacím jazyku Kawa</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Zpracování vektorů, matic a N-rozměrných polí v programovacím jazyku Kawa</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešní části seriálu o světě lispovských programovacích jazyků, si ukážeme, jakým způsobem se v jazyku Kawa pracuje s vektory a maticemi. Tato velmi důležitá oblast informatiky, která je někdy nazývána array programming, se neustále rozvíjí, což zasáhlo i jazyky postavené na LISPu (Racket, Kawa, Clojure).</p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Array programming a specializované programovací jazyky určené pro zpracování matic</a></p>
<p><a href="#k02">*** 2. Zpracování vektorů a matic v&nbsp;programovacím jazyku Kawa</a></p>
<p><a href="#k03">*** 3. Použití javovských polí v&nbsp;programovacím jazyku Kawa</a></p>
<p><a href="#k04">*** 4. Instrukce bajtkódu JVM určené pro konstrukci polí</a></p>
<p><a href="#k05">*** 5. Inicializace prvků polí</a></p>
<p><a href="#k06">*** 6. Vícerozměrná javovská pole</a></p>
<p><a href="#k07">*** 7. Vektory</a></p>
<p><a href="#k08">*** 8. N-rozměrná pole (ND-array)</a></p>
<p><a href="#k09">*** 9. Inicializace prvků N-rozměrných polí</a></p>
<p><a href="#k10">*** 10. Specifikace rozsahu (<strong>range</strong>)</a></p>
<p><a href="#k11">*** 11. Inicializace N-rozměrných polí s&nbsp;využitím rozsahů</a></p>
<p><a href="#k12">*** 12. Nepravidelná N-rozměrná pole</a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. Malá odbočka na závěr: knihovny pro práci s&nbsp;vektory a maticemi pro programovací jazyk Clojure</a></p>
<p><a href="#k16">*** 16. Knihovna <strong>core.matrix</strong></a></p>
<p><a href="#k17">*** 17. Obsah následující části seriálu</a></p>
<p><a href="#k18">*** 18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">*** 19. Literatura</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Array programming a specializované programovací jazyky určené pro zpracování matic</h2>

<p>Dnes se budeme zabývat jednou poměrně rozsáhlou oblastí v&nbsp;IT. Tou je zpracování vektorů, matic a vícerozměrných polí, protože s&nbsp;těmito strukturami se můžeme setkat v&nbsp;různých disciplínách, například ve finančnictví, pojišťovnictví, statistice, zpracování numerických dat, simulacích atd. Současně se jedná i o velmi zajímavou oblast, neboť právě kvůli co nejrychlejší práci s&nbsp;velkými maticemi byly vytvořeny speciální výpočetní bloky v&nbsp;některých superpočítačích (příkladem mohou být superpočítače <i>Cray</i>) a došlo tak k&nbsp;důležitému podnětu pro další rozvoj výpočetní techniky. Současné knihovny dokážou v&nbsp;případě potřeby využít jak některé rozšíření instrukčních sad (SIMD instrukce typu SSE neboli Streaming SIMD Extensions, původně též MMX či 3DNow!), tak i programovatelné grafické akcelerátory (GPU). SIMD instrukcemi jsme se již zabývali v&nbsp;samostatných článcích, zejména v&nbsp;:</p>

<ol>

<li>SIMD instrukce využívané v moderních mikroprocesorech řady x86<br />
<a href="https://www.root.cz/clanky/simd-instrukce-vyuzivane-v-modernich-mikroprocesorech-rady-x86/">https://www.root.cz/clanky/simd-instrukce-vyuzivane-v-modernich-mikroprocesorech-rady-x86/</a>
</li>

<li>SIMD instrukce v moderních mikroprocesorech řady x86 (2.část: SSE)<br />
<a href="https://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-2-cast-sse/">https://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-2-cast-sse/</a>
</li>

<li>SIMD instrukce v moderních mikroprocesorech řady x86 (3.část: SSE2)<br />
<a href="https://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-3-cast-sse2/">https://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-3-cast-sse2/</a>
</li>

</ol>

<p>Práce s&nbsp;vektory a maticemi byla (a samozřejmě doposud je) podporována v&nbsp;překladačích FORTRANu, které začaly být po vzniku superpočítačů vybaveny algoritmy, které dokázaly převést některé typy programových smyček na &bdquo;vektorové operace&ldquo;. Paralelně vznikly i specializované jazyky určené téměř výhradně pro práci s&nbsp;vektory i maticemi. Velmi dobrým příkladem jsou programovací jazyky <i>APL</i> a <i>J</i>. I těmito neobvyklými programovacími jazyky jsme se na stránkách Rootu již zabývali:</p>

<ol>

<li>Programování mainframů: jazyk APL<br />
<a href="https://www.root.cz/clanky/programovani-mainframu-jazyk-apl/">https://www.root.cz/clanky/programovani-mainframu-jazyk-apl/</a>
</li>

<li>Programovací jazyk APL: programování bez smyček<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-apl-programovani-bez-smycek/">https://www.root.cz/clanky/programovaci-jazyk-apl-programovani-bez-smycek/</a>
</li>

<li>Programovací jazyk APL - dokončení<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-apl-dokonceni/">https://www.root.cz/clanky/programovaci-jazyk-apl-dokonceni/</a>
</li>

<li>Programovací jazyk J – od hieroglyfů k ASCII znakům<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-j-ndash-od-hieroglyfu-k-nbsp-ascii-znakum/">https://www.root.cz/clanky/programovaci-jazyk-j-ndash-od-hieroglyfu-k-nbsp-ascii-znakum/</a>
</li>

<li>Programujeme v jazyku J: vektory a matice<br />
<a href="https://www.root.cz/clanky/programujeme-v-jazyku-j-ndash-vektory-a-matice/">https://www.root.cz/clanky/programujeme-v-jazyku-j-ndash-vektory-a-matice/</a>
</li>

<li>Programovací jazyk J: operátory, uživatelské funkce a tacit programming<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-j-operatory-uzivatelske-funkce-a-tacit-programming/">https://www.root.cz/clanky/programovaci-jazyk-j-operatory-uzivatelske-funkce-a-tacit-programming/</a>
</li>

</ol>

<p>Velmi dobrou podporu pro práci s&nbsp;maticemi ovšem nabízí i framework <a href="https://www.root.cz/serialy/torch-framework-pro-strojove-uceni/">Torch</a> založený na jazyku Lua, <a href="">programovací jazyk Julia</a> a knihovna <a href="">Numpy</a> určená pro programovací jazyk Python. Opět uvedu odkazy na články, v&nbsp;níž se touto populární a velmi často používanou knihovnou zabýváme do větší hloubky, než to umožňuje rozsah dnešního článku:</p>

<ol>

<li>Integrovaná vývojová prostředí ve Fedoře: vykreslování grafů s využitím knihoven Numpy a matplotlib<br />
<a href="https://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-vykreslovani-grafu-s-vyuzitim-knihoven-numpy-a-matplotlib/">https://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-vykreslovani-grafu-s-vyuzitim-knihoven-numpy-a-matplotlib/</a>
</li>

<li>Integrovaná vývojová prostředí ve Fedoře: praktické použití IPython Notebooku a knihovny Numpy (2.část)<br />
<a href="https://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-prakticke-pouziti-ipython-notebooku-a-knihovny-numpy-2-cast/">https://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-prakticke-pouziti-ipython-notebooku-a-knihovny-numpy-2-cast/</a>
</li>

<li>Integrovaná vývojová prostředí ve Fedoře: praktické použití IPython Notebooku a knihovny Numpy<br />
<a href="https://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-prakticke-pouziti-ipython-notebooku-a-knihovny-numpy/">https://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-prakticke-pouziti-ipython-notebooku-a-knihovny-numpy/</a>
</li>

</ol>



<p><a name="k02"></a></p>
<h2 id="k02">2. Zpracování vektorů a matic v&nbsp;programovacím jazyku Kawa</h2>

<p>V&nbsp;dnešním článku budeme zabývat především tím, jak se matice (prakticky libovolných rozměrů, tedy i vektory) používají v&nbsp;programovacím jazyku <i>Kawa</i>, kterému jsme se podrobně věnovali <a href="">minule</a> a <a href="">předminule</a>. V&nbsp;této oblasti je <i>Kawa</i> v&nbsp;poněkud schizofrenní situace, protože pochopitelně podporuje klasické LISPovské vektory (nejedná se sice o zcela základní datový typ, ovšem prakticky každá implementace LISPu či Scheme práci s&nbsp;vektory umožňuje), dále podporuje pole (<i>array</i>) vycházející z&nbsp;konceptů, které se objevily <a href="https://racket-lang.org/">v&nbsp;jazyce Racket</a>, konkrétně ve standardním modulu <a href="https://docs.racket-lang.org/math/array.html">math-array</a> a zapomenout nesmíme ani na možnost použít pole kompatibilní s&nbsp;programovacím jazykem Java a podporované přímo v&nbsp;bajtkódu JVM (viz též předchozí část tohoto seriálu).</p>

<p>Kromě toho si na konci článku připomeneme existenci knihovny nazvané <strong>core.matrix</strong>, která vývojářům pracujícím s&nbsp;programovacím jazykem Clojure nabízí prakticky všechny potřebné operace, které se při práci s&nbsp;vektory a maticemi používají (včetně například výpočtu inverzní matice). Navíc je tato knihovna zajímavá tím, že předepisuje <i>rozhraní</i> pro všechny operace, ovšem konkrétní implementaci je možné vybrat. To například znamená, že pokud je řešen nějaký problém, v&nbsp;němž se ve velké míře používají takzvané řídké matice (pěkným příkladem z&nbsp;praxe může být <i>Google matrix</i>), lze &ndash; beze změny uživatelského programu &ndash; vybrat takovou reprezentaci matic a takové algoritmy, které jsou optimalizovány právě pro práci s&nbsp;řídkými maticemi a nikoli s&nbsp;maticemi uloženými ve formě dvourozměrného pole.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Použití javovských polí v&nbsp;programovacím jazyku Kawa</h2>

<p>Nejprve si ukažme, jakým způsobem je možné v&nbsp;programovacím jazyku <i>Kawa</i> pracovat s&nbsp;poli plně kompatibilními s&nbsp;Javou a tím pádem samozřejmě i s&nbsp;virtuálním strojem Javy. Připomeňme si, že v&nbsp;Javě mají pole poměrně speciální postavení, protože se jedná o kontejner, který dokáže uložit známý počet prvků určitého typu (počet prvků musí být specifikován při konstrukci pole). Samozřejmě je možné, aby pole obsahovalo jako své prvky další pole, čímž je umožněno vytvářet matice i vícerozměrné datové struktury, které navíc nemusí mít nutně obdélníkový či čtvercový tvar. Interně je pole v&nbsp;operační paměti, přesněji řečeno na haldě (<i>heap</i>) uloženo v&nbsp;jediném souvislém bloku, ovšem musíme si přesně uvědomit co to znamená &ndash; pole, jehož prvky jsou primitivními datovými typy je skutečně tvořeno souvislým blokem, ovšem pole objektů je ve skutečnosti realizováno blokem obsahujícím <i>reference</i> popř.&nbsp;speciální hodnotu <strong>null</strong>, zatímco vlastní objekty jsou alokovány na jiném místě haldy a pouze odkaz (reference) na ně je uložena v&nbsp;poli.</p>

<p>Vícerozměrná pole jsou vlastně &bdquo;pole polí&ldquo; a tudíž pole obsahující reference (což je jeden z&nbsp;poměrně zásadních rozdílů mezi Javou a jazykem C v&nbsp;této oblasti).</p>

<p>Toto uspořádání přináší některé výhody, ale i nevýhody. Mezi výhody patří relativně snadná práce <i>garbage collectoru</i> při přenášení pole v&nbsp;rámci jednotlivých regionů, na něž je halda rozdělena (více viz <a href=""></a>) a zmenšuje se i počet tzv.&nbsp;<i></i>, ovšem počet objektů a spotřeba operační paměti poměrně rychle narůstá, protože velká část haldy může obsahovat pouze reference na objekty (extrémním příkladem může být rastrový obrázek, v&nbsp;němž jsou jednotlivé pixely realizovány instancemi třídy <strong>Color</strong>).</p>

<p>V&nbsp;programovacím jazyku <i>Kawa</i> je umožněno vytvářet klasická Javovská pole libovolného typu. Nejjednodušší je situace v&nbsp;případě, že se má jednat o pole s&nbsp;prvky primitivních datových typů. Vytvoření takového pole, zde konkrétně pole prvků typu <strong>int</strong> může vypadat následovně:</p>

<pre>
(define array1 (int[] length: 10))
&nbsp;
(display array1)
(newline)
</pre>

<p>S&nbsp;tímto výsledkem:</p>

<pre>
[0 0 0 0 0 0 0 0 0 0]
</pre>

<p>Samozřejmě je možné vytvořit funkci, která pole zkonstruuje a vrátí ho jako svoji návratovou hodnotu:</p>

<pre>
(define (<strong>createArray</strong> length)
  (int[] length: length))
&nbsp;
(let ((array1 (createArray 10)))
    (display array1)
    (newline))
</pre>

<p>Výsledek:</p>

<pre>
</pre>

<p>Změna hodnoty prvku pole:</p>

<pre>
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že jméno funkce měnící pole končí vykřičníkem, podobně jako další podobně koncipované funkce, které obecně mění stav aplikace. Dále si povšimněte, že se prvky indexují od nuly, stejně jako v&nbsp;C a Javě.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Instrukce bajtkódu JVM určené pro konstrukci polí</h2>

<p>Konstrukce pole a přístup k&nbsp;prvkům pole je plně podporován i bajtkódem virtuálního stroje Javy. Zatímco objekty se vytváří pomocí instrukce <strong>new</strong> a pro přístup k&nbsp;jejich atributům se používají instrukce <strong>getfield</strong> a <strong>putfield</strong>, je situace v&nbsp;případě polí odlišná, protože se pro pole používá dvacet specializovaných instrukcí sloužících jak pro vytvoření pole, tak i pro přístup k&nbsp;jeho prvkům, popř.&nbsp;pro zjištění délky pole.</p>

<p>První instrukcí, se kterou se dnes seznámíme, je instrukce nazvaná <strong>newarray</strong>. Pravděpodobně uhodnete, k&nbsp;čemu tato instrukce slouží &ndash; lze ji použít pro vytvoření pole dané délky, ovšem pouze v&nbsp;tom případě, pokud má pole obsahovat prvky některého z&nbsp;primitivních datových typů, tj.&nbsp;pravdivostní hodnoty, znaky, celá čísla či čísla s&nbsp;plovoucí řádovou čárkou. Jinými slovy to znamená, že tuto instrukci nelze použít například pro vytvoření pole objektů. Formát instrukce <strong>newarray</strong> je vypsán v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operandy</th><th>Prováděná operace</th></tr>
<tr><td>1</td><td>newarray</td><td>0xBC</td><td>arraytype</td><td>Vytvoří nové pole s prvky primitivního datového typu</td></tr>
</table>

<p>Instrukce <strong>newarray</strong> očekává, že na vrcholu zásobníku operandů (<i>TOS</i>) bude uložena hodnota typu <strong>int</strong> udávající velikost pole. Tato hodnota je ze zásobníku v&nbsp;průběhu vytváření pole odstraněna a namísto ní se na vrchol zásobníku operandů uloží reference na právě vytvořené pole. Ještě nám zbývá popsat operand instrukce <strong>newarray</strong> nazvaný <i>arraytype</i>. Jde o jednobajtový operand, jehož hodnota určuje typ prvků vytvářeného pole. Jak jsme si již řekli v&nbsp;předchozím odstavci, může se pomocí instrukce <strong>newarray</strong> vytvořit pole složené z&nbsp;pravdivostních hodnot, znaků, celých čísel či čísel s&nbsp;plovoucí řádovou čárkou (ve všech případech se jedná o primitivní datové typy):</p>

<table>
<tr><th>Arraytype</th><th>Typ prvků pole</th></tr>
<tr><td> 4</td><td>boolean</td></tr>
<tr><td> 5</td><td>char</td></tr>
<tr><td> 6</td><td>float</td></tr>
<tr><td> 7</td><td>double</td></tr>
<tr><td> 8</td><td>byte</td></tr>
<tr><td> 9</td><td>short</td></tr>
<tr><td>10</td><td>int</td></tr>
<tr><td>11</td><td>long</td></tr>
</table>

<pre>
5: bipush        10
7: newarray      int
</pre>

<pre>
  public static int[] createArray(java.lang.Object);
    Code:
       0: aload_0       
       1: invokestatic  #16                 // Method gnu/mapping/Promise.force:(Ljava/lang/Object;)Ljava/lang/Object;
       4: checkcast     #18                 // class java/lang/Number
       7: invokevirtual #22                 // Method java/lang/Number.intValue:()I
      10: newarray       int
      12: areturn       
</pre>

<pre>
(define (createArray length :: int)
  (int[] length: length))

(let ((array1 (createArray 10)))
    (display array1)
    (newline))
</pre>

<pre>
  public static int[] createArray(int);
    Code:
       0: iload_0       
       1: newarray       int
       3: areturn       
</pre>

<p>Další instrukcí používanou při vytváření polí je instrukce nazvaná <strong>anewarray</strong> (na začátku jména této instrukce se nachází znak &bdquo;a&ldquo;). Tato instrukce se používá pro vytvoření pole, jehož prvky jsou objekty, a to objekty libovolného (specifikovaného) typu. Zatímco se u instrukce <strong>newarray</strong> specifikoval typ prvků pole pomocí hodnoty bajtu uloženého ihned za operačním kódem instrukce, je nutné u instrukce <strong>anewarray</strong> použít celé jméno třídy, rozhraní či výčtového typu (udávající typ prvků pole).  Toto jméno třídy je, jak pravděpodobně již tušíte, uložené v&nbsp;<i>constant poolu</i>, takže se za operačním kódem instrukce <strong>anewarray</strong> nachází dvojice bajtů představujících index záznamu v&nbsp;<i>constant poolu</i>. Chování obou zmíněných instrukcí však zůstává stejné &ndash; z&nbsp;vrcholu zásobníku operandů se vyzvedne hodnota typu <i>int</i> představující velikost pole, pole daného typu se vytvoří a následně se na zásobník operandů uloží reference na vytvořený objekt (v&nbsp;případě polí objektů samozřejmě nejsou tyto objekty vytvořeny a pole obsahuje hodnoty <strong>null</strong>):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operandy</th><th>Prováděná operace</th></tr>
<tr><td>1</td><td>anewarray</td><td>0xBD</td><td>highbyte, lowbyte</td><td>Vytvoří nové pole objektů</td></tr>
</table>



<p><a name="k05"></a></p>
<h2 id="k05">5. Inicializace prvků polí</h2>

<pre>
(define array2 (int[] 1 2 3 4 5))

(display array2)
(newline)

(set! (array2 2) -1)

(display array2)
(newline)
</pre>

<pre>
[1 2 3 4 5]
[1 2 -1 4 5]
</pre>

<pre>
(define array2 (int[] 100 200 300 400 500))
(set! (array2 2) -1)
</pre>

<pre>
  public final void run(gnu.mapping.CallContext);
    Code:
       0: aload_1       
       1: getfield      #8                  // Field gnu/mapping/CallContext.consumer:Lgnu/lists/Consumer;
       4: astore_2      
       5: iconst_5      
       6: newarray       int
       8: dup           
       9: iconst_0      
      10: bipush        100
      12: iastore       
      13: dup           
      14: iconst_1      
      15: sipush        200
      18: iastore       
      19: dup           
      20: iconst_2      
      21: sipush        300
      24: iastore       
      25: dup           
      26: iconst_3      
      27: sipush        400
      30: iastore       
      31: dup           
      32: iconst_4      
      33: sipush        500
      36: iastore       
      37: putstatic     #12                 // Field array2:[I
      40: getstatic     #12                 // Field array2:[I
      43: iconst_2      
      44: iconst_m1     
      45: iastore       
      46: return        
</pre>

<pre>
(define array3 (float[] 100 200 300 400 500 600 700 800 900 1000))

(display array3)
(newline)

(set! (array3 9) -1000)

(display array3)
(newline)
</pre>

<pre>
[100.0 200.0 300.0 400.0 500.0 600.0 700.0 800.0 900.0 1000.0]
[100.0 200.0 300.0 400.0 500.0 600.0 700.0 800.0 900.0 -1000.0]
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Vícerozměrná javovská pole</h2>

<pre>
(define matrix1 (int[][] [1 2 3] [4 5 6] [7 8 9]))

(display matrix1)
(newline)
</pre>

<pre>
[[1 2 3] [4 5 6] [7 8 9]]
</pre>

<pre>
(define matrix2 (int[][] [1] [2 3] [4 5 6] [7 8 9 10]))

(display matrix2)
(newline)
</pre>

<pre>
[[1] [2 3] [4 5 6] [7 8 9 10]]
</pre>

<pre>
(define matrix3 (float[][] [1] [2 3] [4 5 6] [7 8 9 10]))

(display matrix3)
(newline)
</pre>

<pre>
[[1.0] [2.0 3.0] [4.0 5.0 6.0] [7.0 8.0 9.0 10.0]]
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Vektory</h2>

<pre>
(define vector1 [1 2 3 4])

(display vector1)
(newline)

(display (vector-ref vector1 0))
(display (vector-ref vector1 10))
</pre>

<pre>
(define vector2 (vector 1 2 3 4 5))

(display vector2)
(newline)

(display (vector-ref vector2 0))
(newline)

(vector-set! vector2 2 -1)

(display vector2)
(newline)
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. N-rozměrná pole (ND-Array)</h2>

#|kawa:7|# (make-array [1 2])
╔#2a:1:2══════╗
║#!null│#!null║
╚══════╧══════╝
#|kawa:8|# (make-array [1])
#(#!null)
#|kawa:9|# (make-array [1 1])
╔#2a:1:1
║#!null║
╚══════╝
#|kawa:10|# (make-array [2 3])
╔#2a:2:3══════╤══════╗
║#!null│#!null│#!null║
╟──────┼──────┼──────╢
║#!null│#!null│#!null║
╚══════╧══════╧══════╝
#|kawa:11|# (make-array [2 3 4])
╔#3a:2:3:4════╤══════╤══════╗
║#!null│#!null│#!null│#!null║
╟──────┼──────┼──────┼──────╢
║#!null│#!null│#!null│#!null║
╟──────┼──────┼──────┼──────╢
║#!null│#!null│#!null│#!null║
╠══════╪══════╪══════╪══════╣
║#!null│#!null│#!null│#!null║
╟──────┼──────┼──────┼──────╢
║#!null│#!null│#!null│#!null║
╟──────┼──────┼──────┼──────╢
║#!null│#!null│#!null│#!null║
╚══════╧══════╧══════╧══════╝

#|kawa:12|# (make-array [4 3 2])
╔#3a:4:3:2════╗
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╠══════╪══════╣
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╠══════╪══════╣
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╠══════╪══════╣
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╚══════╧══════╝



<p><a name="k09"></a></p>
<h2 id="k09">9. Inicializace prvků N-rozměrných polí</h2>

#|kawa:1|# (make-array [2 4] 1 2 3 4 5)
╔#2a:2:4╗
║1│2│3│4║
╟─┼─┼─┼─╢
║5│1│2│3║
╚═╧═╧═╧═╝
#|kawa:2|# (make-array [2 3 4] 1 2 3 4 5)
#3a:2:3:4
║1│2│3│4║
╟─┼─┼─┼─╢
║5│1│2│3║
╟─┼─┼─┼─╢
║4│5│1│2║
╠═╪═╪═╪═╣
║3│4│5│1║
╟─┼─┼─┼─╢
║2│3│4│5║
╟─┼─┼─┼─╢
║1│2│3│4║
╚═╧═╧═╧═╝

#|kawa:11|# (make-array [2 2 2 3] 1 2 3)
#4a═╤═╗
║1│2│3║
╟─┼─┼─╢
║1│2│3║
╠═╪═╪═╣
║1│2│3║
╟─┼─┼─╢
║1│2│3║
╠═╪═╪═╣
║1│2│3║
╟─┼─┼─╢
║1│2│3║
╠═╪═╪═╣
║1│2│3║
╟─┼─┼─╢
║1│2│3║
╚═╧═╧═╝



<p><a name="k10"></a></p>
<h2 id="k10">10. Specifikace rozsahu (<strong>range</strong>)</h2>

<p><a name="k11"></a></p>
<h2 id="k11">11. Inicializace N-rozměrných polí s&nbsp;využitím rozsahů</h2>

#|kawa:3|# (index-array [[1 <: 3] [2 <: 6]])
#2a@1:2@2:4
║0│1│2│3║
╟─┼─┼─┼─╢
║4│5│6│7║
╚═╧═╧═╧═╝

#|kawa:5|# (index-array [[1 <: 4] [1 <: 4] [1 <: 4]])
#3a@1:3@1:3@1:3
║ 0│ 1│ 2║
╟──┼──┼──╢
║ 3│ 4│ 5║
╟──┼──┼──╢
║ 6│ 7│ 8║
╠══╪══╪══╣
║ 9│10│11║
╟──┼──┼──╢
║12│13│14║
╟──┼──┼──╢
║15│16│17║
╠══╪══╪══╣
║18│19│20║
╟──┼──┼──╢
║21│22│23║
╟──┼──┼──╢
║24│25│26║
╚══╧══╧══╝




<p><a name="k12"></a></p>
<h2 id="k12">12. Nepravidelná N-rozměrná pole</h2>

#|kawa:52|# (array [2 3]
#2a((1 2) (3 4)) 9 #2a((3 4) (5 6))
[42 43] #2a:1:3((8 7 6)) #2a((90 91) (100 101)))#|.....53|# #|.....54|# 
╔#2a:2:3╤═══════╤═════════╗
║#2a═╗  │      9│#2a═╗    ║
║║1│2║  │       │║3│4║    ║
║╟─┼─╢  │       │╟─┼─╢    ║
║║3│4║  │       │║5│6║    ║
║╚═╧═╝  │       │╚═╧═╝    ║
╟───────┼───────┼─────────╢
║╔#1a:2╗│#2a:1:3│╔#2a:2:2╗║
║║42│43║│║8│7│6║│║ 90│ 91║║
║╚══╧══╝│╚═╧═╧═╝│╟───┼───╢║
║       │       │║100│101║║
║       │       │╚═══╧═══╝║
╚═══════╧═══════╧═════════╝

#|kawa:17|# (array [[1 <=: 2] [1 <=: 3]]
#2a((1 2) (3 4)) 9 #2a((3 4) (5 6))
[42 43] #2a:1:3((8 7 6)) #2a((90 91) (100 101)))#|.....18|# #|.....19|# 
╔#2a@1:2@1:3════╤═════════╗
║#2a═╗  │      9│#2a═╗    ║
║║1│2║  │       │║3│4║    ║
║╟─┼─╢  │       │╟─┼─╢    ║
║║3│4║  │       │║5│6║    ║
║╚═╧═╝  │       │╚═╧═╝    ║
╟───────┼───────┼─────────╢
║╔#1a:2╗│#2a:1:3│╔#2a:2:2╗║
║║42│43║│║8│7│6║│║ 90│ 91║║
║╚══╧══╝│╚═╧═╧═╝│╟───┼───╢║
║       │       │║100│101║║
║       │       │╚═══╧═══╝║
╚═══════╧═══════╧═════════╝



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. Malá odbočka na závěr: knihovny pro práci s&nbsp;vektory a maticemi pro programovací jazyk Clojure</h2>

<p>Pojďme si nyní alespoň ve stručnosti připomenout, jakým způsobem je práce s&nbsp;maticemi podporována v&nbsp;programovacím jazyku <i>Clojure</i>. Při studiu základních knihoven Clojure je možné dojít k&nbsp;závěru, že vlastně jen velmi málo funkcí a maker je určeno pro práci s&nbsp;těmito datovými typy, i když je samozřejmě možné jak vektory, tak i matice velmi snadno reprezentovat s&nbsp;využitím základních sekvenčních datových struktur Clojure &ndash; seznamů a vektorů. Ve skutečnosti to však není zcela ideální řešení, a to hned z&nbsp;několika důvodů, jejichž společným rysem je rychlost prováděných operací. Z&nbsp;tohoto důvodu je v&nbsp;případě implementace algoritmů, v&nbsp;nichž se intenzivně používají operace s&nbsp;maticemi, mnohem výhodnější využít možností specializovaných knihoven. My se dnes seznámíme především s&nbsp;elegantně navrženou knihovnou <strong>core.matrix</strong>. Příště se budeme zabývat ještě výkonnějším řešením: knihovnou <i>Neanderthal</i>, která využívá vysoce optimalizovanou nativní knihovnu <i>ATLAS (Automatically Tuned Linear Algebra Software)</i> s&nbsp;možností využití vysokého výpočetního výkonu současných GPU.</p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Knihovna <strong>core.matrix</strong></h2>

<p>V&nbsp;přednášce nazvané velmi příhodně &bdquo;Enter the Matrix&ldquo;, která je dostupná na adrese <a href="http://www.slideshare.net/mikeranderson/2013-1114-enter-thematrix">http://www.slideshare.net/mikeranderson/2013-1114-enter-thematrix</a>, je mj.&nbsp;ukázáno, jakým způsobem jsou v&nbsp;Clojure implementována různá paradigmata programování. Díky podpoře maker a způsobu zápisu programového kódu v&nbsp;Clojure lze velmi snadno implementovat různé doménově specifické jazyky (DSL), mj.&nbsp;i právě jazyk pro array programming:</p>

<table>
<tr><th>Paradigma</th><th>Jazyk</th><th>Implementace v&nbsp;Clojure</th></tr>
<tr><td>funkcionální</td><td>Haskell</td><td>clojure.core</td></tr>
<tr><td>OOP</td><td>Smalltalk</td><td>clojure.core</td></tr>
<tr><td>metaprogramování</td><td>Lisp</td><td>clojure.core</td></tr>
<tr><td>logické</td><td>Prolog</td><td>core.logic</td></tr>
<tr><td>array programming</td><td>APL, J</td><td>core.matrix</td></tr>
</table>

<p><i>(Poznámka: původní tabulka byla upravena a doplněna)</i></p>

<p>V&nbsp;dalším textu se budeme zabývat knihovnou nazvanou <strong>core.matrix</strong>, která je určena těm vývojářům, kteří ve svých projektech potřebují provádět velké množství operací s&nbsp;těmito strukturami, a to na poměrně vysoké úrovni, tj.&nbsp;bez nutnosti přesně specifikovat, jak mají být matice uloženy v&nbsp;paměti, jakým způsobem provádět operaci násobení matic atd. Díky tomuto přístupu a taktéž díky vlastnostem programovacího jazyka <i>Clojure</i> (existence tzv.&nbsp;threading makra a funkcí vyššího řádu) se práce s&nbsp;maticemi do značné míry začíná podobat práci v&nbsp;APL, až na ten rozdíl, že algoritmy zapisované v&nbsp;<i>Clojure</i> jsou pro většinu vývojářů přece jen čitelnější :-). Důležité je, že <i>rozhraní</i> definované v&nbsp;knihovně <strong>core.matrix</strong> může mít několik implementací.  V&nbsp;současnosti se jedná o <i>vectorz-clj</i>, <i>Clatrix</i> a <i>NDArray</i>. V&nbsp;<strong>core.matrix</strong> navíc došlo k&nbsp;rozšíření operátorů +, - atd. takovým způsobem, že je lze použít i pro zpracování vektorů a matic (ve skutečnosti se samozřejmě nejedná o skutečné operátory, protože tento koncept <i>Clojure</i> a vlastně ani žádný další lispovský jazyk nepotřebuje).</p>

<p>Funkce a makra nabízená knihovnou <strong>core.matrix</strong> nejlépe prozkoumáme přímo s&nbsp;využitím REPLu, tj.&nbsp;interaktivního rozhraní, v&nbsp;němž ihned po zadání dochází k&nbsp;expanzi maker a vyhodnocování funkcí:</p>

<h3>Konstrukce vektorů a matic</h3>

<pre>
<i>; vektor</i>
matrixtest.core=&gt; <strong>(matrix [1 2 3])</strong>
[1 2 3]
&nbsp;
<i>; vektor</i>
matrixtest.core=&gt; <strong>(matrix '(1 2 3))</strong>
[1 2 3]
&nbsp;
<i>; matice</i>
matrixtest.core=&gt; <strong>(matrix [[1 2] [3 4]])</strong>
[[1 2] [3 4]]
&nbsp;
<i>; matice</i>
matrixtest.core=&gt; <strong>(matrix (range 1 10))</strong>
[1 2 3 4 5 6 7 8 9]
&nbsp;
<i>; matice</i>
matrixtest.core=&gt; <strong>(matrix [[1 2 3] [4 5 6] [7 8 9]])</strong>
[[1 2 3] [4 5 6] [7 8 9]]
</pre>

<h3>Pretty printing matic a vektorů</h3>

<pre>
matrixtest.core=&gt; <strong>(pm (matrix [[1 2] [3 4]]))</strong>
[[1.000 2.000]
 [3.000 4.000]]
&nbsp;
matrixtest.core=&gt; <strong>(matrix [[1 2] [3 4]])</strong>
[[1 2] [3 4]]
&nbsp;
<i>; *1 obsahuje výsledek poslední vyhodnocené funkce či symbolu</i>
matrixtest.core=&gt; <strong>(pm *1)</strong>
[[1.000 2.000]
 [3.000 4.000]]
</pre>

<h3>Konstruktory nulové matice a jednotkové matice</h3>

<pre>
matrixtest.core=&gt; <strong>(zero-matrix 2 3)</strong>
[[0.0 0.0 0.0] [0.0 0.0 0.0]]
&nbsp;
matrixtest.core=&gt; <strong>(pm *1)</strong>
[[0.000 0.000 0.000]
 [0.000 0.000 0.000]]
&nbsp;
matrixtest.core=&gt; <strong>(zero-matrix 4 4)</strong>
[[0.0 0.0 0.0 0.0] [0.0 0.0 0.0 0.0] [0.0 0.0 0.0 0.0] [0.0 0.0 0.0 0.0]]
&nbsp;
matrixtest.core=&gt; <strong>(pm *1)</strong>
[[0.000 0.000 0.000 0.000]
 [0.000 0.000 0.000 0.000]
 [0.000 0.000 0.000 0.000]
 [0.000 0.000 0.000 0.000]]
&nbsp;
matrixtest.core=&gt; <strong>(identity-matrix 4 4)</strong>
[[1.0 0.0 0.0 0.0] [0.0 1.0 0.0 0.0] [0.0 0.0 1.0 0.0] [0.0 0.0 0.0 1.0]]
&nbsp;
matrixtest.core=&gt; <strong>(pm *1)</strong>
[[1.000 0.000 0.000 0.000]
 [0.000 1.000 0.000 0.000]
 [0.000 0.000 1.000 0.000]
 [0.000 0.000 0.000 1.000]]
</pre>

<h3>Konstruktor permutační matice</h3>

<pre>
<i>; vektor udává pozice jedniček na jednotlivých řádcích matice</i>
<i>; rozměry matice jsou získány na základě velikosti tohoto vektoru</i>
matrixtest.core=&gt; <strong>(permutation-matrix [1 4 2 3 0])</strong>
#NDArray [[0.0 1.0 0.0 0.0 0.0] [0.0 0.0 0.0 0.0 1.0] [0.0 0.0 1.0 0.0 0.0] [0.0 0.0 0.0 1.0 0.0] [1.0 0.0 0.0 0.0 0.0]]
&nbsp;
matrixtest.core=&gt; <strong>(pm *1)</strong>
[[0.000 1.000 0.000 0.000 0.000]
 [0.000 0.000 0.000 0.000 1.000]
 [0.000 0.000 1.000 0.000 0.000]
 [0.000 0.000 0.000 1.000 0.000]
 [1.000 0.000 0.000 0.000 0.000]]
</pre>

<h3>Transpozice matice</h3>

<pre>
matrixtest.core=&gt; <strong>(def M (matrix [[1 2] [3 4]]))</strong>
#'matrixtest.core/M
&nbsp;
matrixtest.core=&gt; <strong>M</strong>
[[1 2] [3 4]]
&nbsp;
matrixtest.core=&gt; <strong>(pm *1)</strong>
[[1.000 2.000]
 [3.000 4.000]]
&nbsp;
matrixtest.core=&gt; <strong>(transpose M)</strong>
[[1 3] [2 4]]
&nbsp;
<i>; vypíše se hodnota transponované matice, původní matice M se nemění</i>
matrixtest.core=&gt; <strong>(pm *1)</strong>
[[1.000 3.000]
 [2.000 4.000]]
</pre>

<h3>Unární a binární operace nad maticemi</h3>

<pre>
matrixtest.core=&gt; <strong>(def M1 (matrix [[1 2][3 4]]))</strong>
#'matrixtest.core/M1
&nbsp;
matrixtest.core=&gt; <strong>(def M2 (matrix [[5 6][7 8]]))</strong>
#'matrixtest.core/M2
&nbsp;
matrixtest.core=&gt; <strong>(pm (+ M1 M2))</strong>
[[ 6.000  8.000]
 [10.000 12.000]]
&nbsp;
matrixtest.core=&gt; <strong>(pm (- M1 M2))</strong>
[[-4.000 -4.000]
 [-4.000 -4.000]]
&nbsp;
matrixtest.core=&gt; <strong>(pm (* M1 M2))</strong>
[[ 5.000 12.000]
 [21.000 32.000]]
&nbsp;
matrixtest.core=&gt; <strong>(pm (* M1 100))</strong>
[[100.000 200.000]
 [300.000 400.000]]
&nbsp;
<i>; zde se nejdříve vypočte inverzní matice k M1</i>
matrixtest.core=&gt; <strong>(pm (/ M2 M1))</strong>
[[5.000 3.000]
 [2.333 2.000]]
&nbsp;
matrixtest.core=&gt; <strong>(inverse M1)</strong>
#NDArrayDouble [[-1.9999999999999998 1.0] [1.4999999999999998 -0.49999999999999994]]
&nbsp;
matrixtest.core=&gt; <strong>(inverse M2)</strong>
#NDArrayDouble [[-4.000000000000002 3.0000000000000013] [3.5000000000000018 -2.5000000000000013]]
</pre>

<h3>Funkce vracející informaci o tom, zda je hodnota skalárem či maticí</h3>

<pre>
matrixtest.core=&gt; <strong>(def v (matrix [1 2 3 4 5 6]))</strong>
#'matrixtest.core/v
&nbsp;
matrixtest.core=&gt; <strong>(def M (matrix [[1 2] [3 4]]))</strong>
#'matrixtest.core/M
&nbsp;
<i>; jen 42 je skalární hodnota</i>
matrixtest.core=&gt; <strong>(for [obj [42 v M MD]] (array? obj))</strong>
(false true true true)
&nbsp;
<i>; jen 42 je skalární hodnota</i>
matrixtest.core=&gt; <strong>(for [obj [42 v M MD]] (scalar? obj))</strong>
(true false false false)
</pre>

<h3>Funkce vracející informace o maticích (počet dimenzí a tvar)</h3>

<pre>
matrixtest.core=&gt; <strong>(def v (matrix [1 2 3 4 5 6]))</strong>
#'matrixtest.core/v
&nbsp;
matrixtest.core=&gt; <strong>(def M (matrix [[1 2] [3 4]]))</strong>
#'matrixtest.core/M
&nbsp;
<i>; trojrozměrná matice</i>
matrixtest.core=&gt; <strong>(def MD (matrix [[ [1 2] [3 4] ] [ [5 6] [7 8] ] ]))</strong>
#'matrixtest.core/MD
&nbsp;
matrixtest.core=&gt; <strong>(pm MD)</strong>
[[[1.000 2.000]
  [3.000 4.000]]
 [[5.000 6.000]
  [7.000 8.000]]]
&nbsp;
matrixtest.core=&gt; <strong>(dimensionality v)</strong>
1
&nbsp;
matrixtest.core=&gt; <strong>(dimensionality M)</strong>
2
&nbsp;
matrixtest.core=&gt; <strong>(dimensionality MD)</strong>
3
&nbsp;
matrixtest.core=&gt; <strong>(dimensionality 1)</strong>
0
&nbsp;
matrixtest.core=&gt; <strong>(shape M)</strong>
[2 2]
&nbsp;
matrixtest.core=&gt; <strong>(shape v)</strong>
[6]
&nbsp;
matrixtest.core=&gt; <strong>(shape MD)</strong>
[2 2 2]
</pre>

<h3>Přečtení hodnoty prvku matice a získání řezu (slice)</h3>

<pre>
matrixtest.core=&gt; <strong>(mget M 0 0)</strong>
1
&nbsp;
matrixtest.core=&gt; <strong>(slice v 1)</strong>
2
&nbsp;
<i>; řez 2D maticí</i>
matrixtest.core=&gt; <strong>(slice M 1)</strong>
[3 4]
&nbsp;
<i>; řez 3D maticí</i>
matrixtest.core=&gt; <strong>(slice MD 1)</strong>
[[5 6] [7 8]]
&nbsp;
<i>; operace nad řezy</i>
matrixtest.core=&gt; <strong>(for [slice (slices M)] (apply + slice))</strong>
(3 7)
&nbsp;
<i>; vektorová! operace nad řezy</i>
matrixtest.core=&gt; <strong>(apply + (slices M))</strong>
[4 6]
</pre>

<h3>Změna tvaru matice</h3>

<pre>
matrixtest.core=&gt; <strong>(def v (matrix [1 2 3 4 5 6]))</strong>
#'matrixtest.core/v
&nbsp;
matrixtest.core=&gt; <strong>v</strong>
[1 2 3 4 5 6]
&nbsp;
<i>; velmi užitečná funkce převzatá z APL: vektor převeden na matici</i>
matrixtest.core=&gt; <strong>(reshape v [2 3])</strong>
[[1 2 3] [4 5 6]]
&nbsp;
matrixtest.core=&gt; <strong>(pm *1)</strong>
[[1.000 2.000 3.000]
 [4.000 5.000 6.000]]
&nbsp;
<i>; jiný tvar matice</i>
matrixtest.core=&gt; <strong>(reshape v [3 2])</strong>
[[1 2] [3 4] [5 6]]
&nbsp;
matrixtest.core=&gt; <strong>(pm *1)</strong>
[[1.000 2.000]
 [3.000 4.000]
 [5.000 6.000]]
&nbsp;
matrixtest.core=&gt; <strong>(reshape v [1 6])</strong>
[[1 2 3 4 5 6]]
&nbsp;
matrixtest.core=&gt; <strong>(pm *1)</strong>
[[1.000 2.000 3.000 4.000 5.000 6.000]]
&nbsp;
matrixtest.core=&gt; <strong>(reshape v [6 1])</strong>
[[1] [2] [3] [4] [5] [6]]
&nbsp;
<i>; sloupec z&nbsp;vektoru</i>
matrixtest.core=&gt; <strong>(pm *1)</strong>
[[1.000]
 [2.000]
 [3.000]
 [4.000]
 [5.000]
 [6.000]]
</pre>

<h3>Využití makra -&gt; ke kompozici operací</h3>

<pre>
<i>; jedná se o oneliner rozepsaný kvůli větší čitelnosti na čtyři řádky</i>
<strong>(-&gt; (matrix (range 1 101))
    (reshape [10 10])
    transpose
    pm)</strong>
[[ 1.000 11.000 21.000 31.000 41.000 51.000 61.000 71.000 81.000  91.000]
 [ 2.000 12.000 22.000 32.000 42.000 52.000 62.000 72.000 82.000  92.000]
 [ 3.000 13.000 23.000 33.000 43.000 53.000 63.000 73.000 83.000  93.000]
 [ 4.000 14.000 24.000 34.000 44.000 54.000 64.000 74.000 84.000  94.000]
 [ 5.000 15.000 25.000 35.000 45.000 55.000 65.000 75.000 85.000  95.000]
 [ 6.000 16.000 26.000 36.000 46.000 56.000 66.000 76.000 86.000  96.000]
 [ 7.000 17.000 27.000 37.000 47.000 57.000 67.000 77.000 87.000  97.000]
 [ 8.000 18.000 28.000 38.000 48.000 58.000 68.000 78.000 88.000  98.000]
 [ 9.000 19.000 29.000 39.000 49.000 59.000 69.000 79.000 89.000  99.000]
 [10.000 20.000 30.000 40.000 50.000 60.000 70.000 80.000 90.000 100.000]]
&nbsp;
<i>; sekvence operací aplikovaných na matici M1</i>
<strong>(-&gt; M1
    transpose
    inverse
    (* 10000)
    transpose
    (* M2)
    (+ M1)
    pm)</strong>
[[-99999.000  60002.000]
 [105003.000 -39996.000]]
</pre>


<p><a name="k17"></a></p>
<h2 id="k17">17. Obsah následující části seriálu</h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů naprogramovaných
v&nbsp;jazyce Kawa byly uloženy do Git repositáře, který je dostupný na adrese
<a
href="https://github.com/tisnik/lisp-families.git">https://github.com/tisnik/lisp-families.git</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, můžete
namísto toho použít odkazy na jednotlivé příklady, které naleznete
v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td></td><td></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/">https://github.com/tisnik/lisp-families/blob/master/kawa/</a></td></tr>
<tr><td> 2</td><td></td><td></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/">https://github.com/tisnik/lisp-families/blob/master/kawa/</a></td></tr>
<tr><td> 3</td><td></td><td></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/">https://github.com/tisnik/lisp-families/blob/master/kawa/</a></td></tr>
<tr><td> 4</td><td></td><td></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/">https://github.com/tisnik/lisp-families/blob/master/kawa/</a></td></tr>
<tr><td> 5</td><td></td><td></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/">https://github.com/tisnik/lisp-families/blob/master/kawa/</a></td></tr>
<tr><td> 6</td><td></td><td></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/">https://github.com/tisnik/lisp-families/blob/master/kawa/</a></td></tr>
<tr><td> 7</td><td></td><td></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/">https://github.com/tisnik/lisp-families/blob/master/kawa/</a></td></tr>
<tr><td> 8</td><td></td><td></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/">https://github.com/tisnik/lisp-families/blob/master/kawa/</a></td></tr>
<tr><td> 9</td><td></td><td></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/">https://github.com/tisnik/lisp-families/blob/master/kawa/</a></td></tr>
<tr><td>10</td><td></td><td></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/">https://github.com/tisnik/lisp-families/blob/master/kawa/</a></td></tr>
<tr><td>11</td><td></td><td></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/">https://github.com/tisnik/lisp-families/blob/master/kawa/</a></td></tr>
<tr><td>12</td><td></td><td></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/">https://github.com/tisnik/lisp-families/blob/master/kawa/</a></td></tr>
<tr><td>13</td><td></td><td></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/">https://github.com/tisnik/lisp-families/blob/master/kawa/</a></td></tr>
<tr><td>14</td><td></td><td></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/">https://github.com/tisnik/lisp-families/blob/master/kawa/</a></td></tr>
<tr><td>15</td><td></td><td></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/">https://github.com/tisnik/lisp-families/blob/master/kawa/</a></td></tr>
<tr><td>16</td><td></td><td></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/">https://github.com/tisnik/lisp-families/blob/master/kawa/</a></td></tr>
<tr><td>17</td><td></td><td></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/">https://github.com/tisnik/lisp-families/blob/master/kawa/</a></td></tr>
<tr><td>18</td><td></td><td></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/">https://github.com/tisnik/lisp-families/blob/master/kawa/</a></td></tr>
<tr><td>19</td><td></td><td></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/">https://github.com/tisnik/lisp-families/blob/master/kawa/</a></td></tr>
<tr><td>20</td><td></td><td></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/">https://github.com/tisnik/lisp-families/blob/master/kawa/</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Literatura</h2>

<ol>

<li>Peter Seibel<br />
<i>&bdquo;Practical Common Lisp&ldquo;</i><br />
2009
</li>

<li>Paul Graham<br />
<i>&bdquo;ANSI Common Lisp&ldquo;</i><br />
1995
</li>

<li>Gerald Gazdar<br />
<i>&bdquo;Natural Language Processing in Lisp: An Introduction to Computational Linguistics&ldquo;</i><br />
1989
</li>

<li>Peter Norvig<br />
<i>&bdquo;Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp&ldquo;</i><br />
1991
</li>

<li>Alex Mileler et.al.<br />
<i>&bdquo;Clojure Applied: From Practice to Practitioner&ldquo;</i><br />
2015
</li>

<li>
<i>&bdquo;Living Clojure: An Introduction and Training Plan for Developers&ldquo;</i><br />
2015
</li>

<li>Dmitri Sotnikov<br />
<i>&bdquo;Web Development with Clojure: Build Bulletproof Web Apps with Less Code&ldquo;</i><br />
2016
</li>

<li>McCarthy<br />
<i>&bdquo;Recursive functions of symbolic expressions and their computation by machine, part I&ldquo;</i><br />
1960
</li>

<li>R. Kent Dybvig<br />
<i>&bdquo;The Scheme Programming Language&ldquo;</i><br />
2009
</li>

<li>Max Hailperin<br />
<i>&bdquo;Concrete Abstractions&ldquo;</i><br />
1998
</li>

<li>Guy L. Steele<br />
<i>&bdquo;History of Scheme&ldquo;</i><br />
2006, Sun Microsystems Laboratories
</li>

<li>Kolář J., Muller K.:<br />
<i>&bdquo;Speciální programovací jazyky&ldquo;</i><br />
Praha 1981
</li>

<li>
<i>&bdquo;AutoLISP Release 9, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., October 1987
</li>

<li>
<i>&bdquo;AutoLISP Release 10, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., September 1988
</li>

<li>McCarthy, John; Abrahams, Paul W.; Edwards, Daniel J.; Hart, Timothy P.; Levin, Michael I.<br />
<i>&bdquo;LISP 1.5 Programmer's Manual&ldquo;</i><br />
MIT Press. ISBN 0 262 130 1 1 4
</li>

<li>Carl Hewitt; Peter Bishop and Richard Steiger<br />
<i>&bdquo;A Universal Modular Actor Formalism for Artificial Intelligence&ldquo;</i><br />
1973
</li>

<li>Feiman, J.<br />
<i>&bdquo;The Gartner Programming Language Survey (October 2001)&ldquo;</i><br />
Gartner Advisory
</li>

<li>Harold Abelson, Gerald Jay Sussman, Julie Sussman:<br />
<i>Structure and Interpretation of Computer Programs</i><br />
MIT Press. 1985, 1996 (a možná vyšel i další přetisk)
</li>

<li>Paul Graham<br />
<i>On Lisp</i><br />
Prentice Hall, 1993<br />
Dostupné online na stránce <a href="http://www.paulgraham.com/onlisptext.html">http://www.paulgraham.com/onlisptext.html</a>
</li>

<li>David S. Touretzky<br />
<i>Common LISP: A Gentle Introduction to Symbolic Computation (Dover Books on Engineering)</i><br />
</li>

<li>Peter Norvig<br />
<i>Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp</i>
</li>

<li>Patrick Winston, Berthold Horn<br />
<i>Lisp (3rd Edition)</i><br />
ISBN-13: 978-0201083194, ISBN-10: 0201083191
</li>

<li>Matthias Felleisen, David Van Horn, Dr. Conrad Barski<br>
<i>Realm of Racket: Learn to Program, One Game at a Time!</i><br />
ISBN-13: 978-1593274917, ISBN-10: 1593274912 
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Kawa: Compiling Scheme to Java<br />
<a href="https://www.mit.edu/afs.new/sipb/project/kawa/doc/kawa-tour.html">https://www.mit.edu/afs.new/sipb/project/kawa/doc/kawa-tour.html</a>
</li>

<li>Kawa in Languages shootout<br />
<a href="http://per.bothner.com/blog/2010/Kawa-in-shootout/">http://per.bothner.com/blog/2010/Kawa-in-shootout/</a>
</li>

<li>Kawa 2.0 Supports Scheme R7RS<br />
<a href="https://developers.slashdot.org/story/14/12/13/2259225/kawa-20-supports-scheme-r7rs/">https://developers.slashdot.org/story/14/12/13/2259225/kawa-20-supports-scheme-r7rs/</a>
</li>

<li>Kawa — fast scripting on the Java platform<br />
<a href="https://lwn.net/Articles/623349/">https://lwn.net/Articles/623349/</a>
</li>

<li>Tail call (a její optimalizace)<br />
<a href="https://en.wikipedia.org/wiki/Tail_call">https://en.wikipedia.org/wiki/Tail_call</a>
</li>

<li>SLIME (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/SLIME">http://en.wikipedia.org/wiki/SLIME</a>
</li>

<li>slime.vim<br />
<a href="http://s3.amazonaws.com/mps/slime.vim">http://s3.amazonaws.com/mps/slime.vim</a>
</li>

<li>What are the best scheme implementations?<br />
<a href="https://www.slant.co/topics/5282/~scheme-implementations">https://www.slant.co/topics/5282/~scheme-implementations</a>
</li>

<li>Bigloo homepage<br />
<a href="http://www-sop.inria.fr/mimosa/fp/Bigloo/">http://www-sop.inria.fr/mimosa/fp/Bigloo/</a>
</li>

<li>FTP s tarbally Bigloo<br />
<a href="ftp://ftp-sop.inria.fr/indes/fp/Bigloo">ftp://ftp-sop.inria.fr/indes/fp/Bigloo</a>
</li>

<li>GOTO 2018 • Functional Programming in 40 Minutes • Russ Olsen<br />
<a href="https://www.youtube.com/watch?v=0if71HOyVjY">https://www.youtube.com/watch?v=0if71HOyVjY</a>
</li>

<li>TinyScheme (stránka na Sourceforge)<br />
<a href="http://tinyscheme.sourceforge.net/home.html">http://tinyscheme.sourceforge.net/home.html</a>
</li>

<li>Embedding Tiny Scheme in a Game<br />
<a href="http://www.silicondelight.com/embedding-tiny-scheme-in-a-game/">http://www.silicondelight.com/embedding-tiny-scheme-in-a-game/</a>
</li>

<li>Embedding Scheme for a game mission scripting DSL<br />
<a href="http://carloscarrasco.com/embedding-scheme-for-a-game-mission-scripting-dsl.html">http://carloscarrasco.com/embedding-scheme-for-a-game-mission-scripting-dsl.html</a>
</li>

<li>Všechny verze TinyScheme na SourceForge<br />
<a href="https://sourceforge.net/projects/tinyscheme/files/tinyscheme/">https://sourceforge.net/projects/tinyscheme/files/tinyscheme/</a>
</li>

<li>Fork TinyScheme na GitHubu<br />
<a href="https://github.com/yawnt/tinyscheme">https://github.com/yawnt/tinyscheme</a>
</li>

<li>Ackermannova funkce<br />
<a href="https://cs.wikipedia.org/wiki/Ackermannova_funkce">https://cs.wikipedia.org/wiki/Ackermannova_funkce</a>
</li>

<li>Ackermann function na Rosetta Code<br />
<a href="https://rosettacode.org/wiki/Ackermann_function#Scheme">https://rosettacode.org/wiki/Ackermann_function#Scheme</a>
</li>

<li>Success Stories (lisp.org)<br />
<a href="https://lisp-lang.org/success/">https://lisp-lang.org/success/</a>
</li>

<li>Allegro Common Lisp Success Stories<br />
<a href="https://franz.com/success/">https://franz.com/success/</a>
</li>

<li>Clojure Success Stories<br />
<a href="https://clojure.org/community/success_stories">https://clojure.org/community/success_stories</a>
</li>

<li>Scheme Quick Reference<br />
<a href="https://www.st.cs.uni-saarland.de/edu/config-ss04/scheme-quickref.pdf">https://www.st.cs.uni-saarland.de/edu/config-ss04/scheme-quickref.pdf</a>
</li>

<li>Slajdy o Scheme (od slajdu číslo 15)<br />
<a href="https://docs.google.com/presentation/d/1abmDnKjrq1tcjGvvRNAKhOiSTSE2lyagtcEPal07Gbo/edit">https://docs.google.com/presentation/d/1abmDnKjrq1tcjGvvRNAKhOiSTSE2lyagtcEPal07Gbo/edit</a>
</li>

<li>Scheme Cheat Sheet<br />
<a href="https://github.com/smythp/scheme-cheat-sheet">https://github.com/smythp/scheme-cheat-sheet</a>
</li>

<li>Embedding Lua, embedding Guile <br />
<a href="http://puntoblogspot.blogspot.com/2013/04/embedding-lua-embedding-guile.html">http://puntoblogspot.blogspot.com/2013/04/embedding-lua-embedding-guile.html</a>
</li>

<li>Lambda Papers<br />
<a href="https://en.wikisource.org/wiki/Lambda_Papers">https://en.wikisource.org/wiki/Lambda_Papers</a>
</li>

<li>Revised<sup>7</sup>Report on the Algorithmic Language Scheme<br />
<a href="https://small.r7rs.org/attachment/r7rs.pdf">https://small.r7rs.org/attachment/r7rs.pdf</a>
</li>

<li>Video Lectures (MIT, SICP 2005)<br />
<a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/">https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/</a>
</li>

<li>Why is Scheme my first language in university?<br />
<a href="https://softwareengineering.stackexchange.com/questions/115252/why-is-scheme-my-first-language-in-university">https://softwareengineering.stackexchange.com/questions/115252/why-is-scheme-my-first-language-in-university</a>
</li>

<li>The Perils of JavaSchools<br />
<a href="https://www.joelonsoftware.com/2005/12/29/the-perils-of-javaschools-2/">https://www.joelonsoftware.com/2005/12/29/the-perils-of-javaschools-2/</a>
</li>

<li>How to Design Programs, Second Edition<br />
<a href="https://htdp.org/2019-02-24/index.html">https://htdp.org/2019-02-24/index.html</a>
</li>

<li>LilyPond<br />
<a href="http://lilypond.org/">http://lilypond.org/</a>
</li>

<li>LilyPond — Extending (přes Scheme)<br />
<a href="http://lilypond.org/doc/v2.18/Documentation/extending/scheme-tutorial">http://lilypond.org/doc/v2.18/Documentation/extending/scheme-tutorial</a>
</li>

<li>Scheme in LilyPond<br />
<a href="http://lilypond.org/doc/v2.18/Documentation/extending/scheme-in-lilypond">http://lilypond.org/doc/v2.18/Documentation/extending/scheme-in-lilypond</a>
</li>

<li>GnuCash<br />
<a href="http://www.gnucash.org/">http://www.gnucash.org/</a>
</li>

<li>Custom Reports (in GNU Cash)<br />
<a href="https://wiki.gnucash.org/wiki/Custom_Reports">https://wiki.gnucash.org/wiki/Custom_Reports</a>
</li>

<li>Program by Design<br />
<a href="https://programbydesign.org/">https://programbydesign.org/</a>
</li>

<li>SchemePy<br />
<a href="https://pypi.org/project/SchemePy/">https://pypi.org/project/SchemePy/</a>
</li>

<li>LISP FQA: Section - [1-5] What is the "minimal" set of primitives needed for a Lisp interpreter?<br />
<a href="http://www.faqs.org/faqs/lisp-faq/part1/section-6.html">http://www.faqs.org/faqs/lisp-faq/part1/section-6.html</a>
</li>

<li>femtolisp<br />
<a href="https://github.com/JeffBezanson/femtolisp">https://github.com/JeffBezanson/femtolisp</a>
</li>

<li>(How to Write a (Lisp) Interpreter (in Python))<br />
<a href="http://norvig.com/lispy.html">http://norvig.com/lispy.html</a>
</li>

<li>Repositář s&nbsp;Guile Emacsem<br />
<a href="http://git.hcoop.net/?p=bpt/guile.git">http://git.hcoop.net/?p=bpt/guile.git</a>
</li>

<li>Interacting with Guile Compound Data Types in C<br />
<a href="http://www.lonelycactus.com/guilebook/x1555.html">http://www.lonelycactus.com/guilebook/x1555.html</a>
</li>

<li>Calling Guile functions from C<br />
<a href="http://www.lonelycactus.com/guilebook/c1204.html#SECCALLGUILEFUNC">http://www.lonelycactus.com/guilebook/c1204.html#SECCALLGUILEFUNC</a>
</li>

<li>Arrays, and other compound data types<br />
<a href="http://www.lonelycactus.com/guilebook/charrays.html">http://www.lonelycactus.com/guilebook/charrays.html</a>
</li>

<li>Interacting with Guile Compound Data Types in C<br />
<a href="http://www.lonelycactus.com/guilebook/x1555.html">http://www.lonelycactus.com/guilebook/x1555.html</a>
</li>

<li>Guile Reference Manual<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/index.html">https://www.gnu.org/software/guile/manual/html_node/index.html</a>
</li>

<li>Scheme: Summary of Common Syntax<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/Syntax-Summary.html#Syntax-Summary">https://www.gnu.org/software/guile/manual/html_node/Syntax-Summary.html#Syntax-Summary</a>
</li>

<li>Scripting with Guile: Extension language enhances C and Scheme<br />
<a href="https://www.ibm.com/developerworks/library/l-guile/index.html">https://www.ibm.com/developerworks/library/l-guile/index.html</a>
</li>

<li>Having fun with Guile: a tutorial<br />
<a href="http://dustycloud.org/misc/guile-tutorial.html">http://dustycloud.org/misc/guile-tutorial.html</a>
</li>

<li>Guile: Loading Readline Support<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/Loading-Readline-Support.html#Loading-Readline-Support">https://www.gnu.org/software/guile/manual/html_node/Loading-Readline-Support.html#Loading-Readline-Support</a>
</li>

<li>lispy<br />
<a href="https://pypi.org/project/lispy/">https://pypi.org/project/lispy/</a>
</li>

<li>Lython<br />
<a href="https://pypi.org/project/Lython/">https://pypi.org/project/Lython/</a>
</li>

<li>Lizpop<br />
<a href="https://pypi.org/project/lizpop/">https://pypi.org/project/lizpop/</a>
</li>

<li>Budoucnost programovacích jazyků<br />
<a href="http://www.knesl.com/budoucnost-programovacich-jazyku">http://www.knesl.com/budoucnost-programovacich-jazyku</a>
</li>

<li>LISP Prolog and Evolution<br />
<a href="http://blog.samibadawi.com/2013/05/lisp-prolog-and-evolution.html">http://blog.samibadawi.com/2013/05/lisp-prolog-and-evolution.html</a>
</li>

<li>List of Lisp-family programming languages<br />
<a href="https://en.wikipedia.org/wiki/List_of_Lisp-family_programming_languages">https://en.wikipedia.org/wiki/List_of_Lisp-family_programming_languages</a>
</li>

<li>clojure_py na indexu PyPi<br />
<a href="https://pypi.python.org/pypi/clojure_py">https://pypi.python.org/pypi/clojure_py</a>
</li>

<li>PyClojure<br />
<a href="https://github.com/eigenhombre/PyClojure">https://github.com/eigenhombre/PyClojure</a>
</li>

<li>Hy na GitHubu<br />
<a href="https://github.com/hylang/hy">https://github.com/hylang/hy</a>
</li>

<li>Hy: The survival guide<br />
<a href="https://notes.pault.ag/hy-survival-guide/">https://notes.pault.ag/hy-survival-guide/</a>
</li>

<li>Hy běžící na monitoru terminálu společnosti Symbolics<br />
<a href="http://try-hy.appspot.com/">http://try-hy.appspot.com/</a>
</li>

<li>Welcome to Hy’s documentation!<br />
<a href="http://docs.hylang.org/en/stable/">http://docs.hylang.org/en/stable/</a>
</li>

<li>Hy na PyPi<br />
<a href="https://pypi.org/project/hy/#description">https://pypi.org/project/hy/#description</a>
</li>

<li>Getting Hy on Python<br />
<a href="https://lwn.net/Articles/596626/">https://lwn.net/Articles/596626/</a>
</li>

<li>Programming Can Be Fun with Hy<br />
<a href="https://opensourceforu.com/2014/02/programming-can-fun-hy/">https://opensourceforu.com/2014/02/programming-can-fun-hy/</a>
</li>

<li>Přednáška o projektu Hy (pětiminutový lighttalk)<br />
<a href="http://blog.pault.ag/day/2013/04/02">http://blog.pault.ag/day/2013/04/02</a>
</li>

<li>Hy (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Hy">https://en.wikipedia.org/wiki/Hy</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Point<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Point.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Point.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Narrowing<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Narrowing.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Narrowing.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Functions that Create Markers<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Markers.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Markers.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Motion<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Motion.html#Motion">https://www.gnu.org/software/emacs/manual/html_node/elisp/Motion.html#Motion</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Basic Char Syntax<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Basic-Char-Syntax.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Basic-Char-Syntax.html</a>
</li>

<li>Elisp: Sequence: List, Array<br />
<a href="http://ergoemacs.org/emacs/elisp_list_vs_vector.html">http://ergoemacs.org/emacs/elisp_list_vs_vector.html</a>
</li>

<li>Elisp: Property List<br />
<a href="http://ergoemacs.org/emacs/elisp_property_list.html">http://ergoemacs.org/emacs/elisp_property_list.html</a>
</li>

<li>Elisp: Hash Table<br />
<a href="http://ergoemacs.org/emacs/elisp_hash_table.html">http://ergoemacs.org/emacs/elisp_hash_table.html</a>
</li>

<li>Elisp: Association List<br />
<a href="http://ergoemacs.org/emacs/elisp_association_list.html">http://ergoemacs.org/emacs/elisp_association_list.html</a>
</li>

<li>The mapcar Function (An Introduction to Programming in Emacs Lisp)<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/mapcar.html">https://www.gnu.org/software/emacs/manual/html_node/eintr/mapcar.html</a>
</li>

<li>Anaphoric macro<br />
<a href="https://en.wikipedia.org/wiki/Anaphoric_macro">https://en.wikipedia.org/wiki/Anaphoric_macro</a>
</li>

<li>Some Common Lisp Loop Macro Examples<br />
<a href="https://www.youtube.com/watch?v=3yl8o6r_omw">https://www.youtube.com/watch?v=3yl8o6r_omw</a>
</li>

<li>A Guided Tour of Emacs<br />
<a href="https://www.gnu.org/software/emacs/tour/">https://www.gnu.org/software/emacs/tour/</a>
</li>

<li>The Roots of Lisp<br />
<a href="http://www.paulgraham.com/rootsoflisp.html">http://www.paulgraham.com/rootsoflisp.html</a>
</li>

<li>Evil (Emacs Wiki)<br />
<a href="https://www.emacswiki.org/emacs/Evil">https://www.emacswiki.org/emacs/Evil</a>
</li>

<li>Evil (na GitHubu)<br />
<a href="https://github.com/emacs-evil/evil">https://github.com/emacs-evil/evil</a>
</li>

<li>Evil (na stránkách repositáře MELPA)<br />
<a href="https://melpa.org/#/evil">https://melpa.org/#/evil</a>
</li>

<li>Evil Mode: How I Switched From VIM to Emacs<br />
<a href="https://blog.jakuba.net/2014/06/23/evil-mode-how-to-switch-from-vim-to-emacs.html">https://blog.jakuba.net/2014/06/23/evil-mode-how-to-switch-from-vim-to-emacs.html</a>
</li>

<li>GNU Emacs (home page)<br />
<a href="https://www.gnu.org/software/emacs/">https://www.gnu.org/software/emacs/</a>
</li>

<li>GNU Emacs (texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?GnuEmacs">http://texteditors.org/cgi-bin/wiki.pl?GnuEmacs</a>
</li>

<li>An Introduction To Using GDB Under Emacs<br />
<a href="http://tedlab.mit.edu/~dr/gdbintro.html">http://tedlab.mit.edu/~dr/gdbintro.html</a>
</li>

<li>An Introduction to Programming in Emacs Lisp<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html">https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html</a>
</li>

<li>27.6 Running Debuggers Under Emacs<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html">https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html</a>
</li>

<li>GdbMode<br />
<a href="http://www.emacswiki.org/emacs/GdbMode">http://www.emacswiki.org/emacs/GdbMode</a>
</li>

<li>Emacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Emacs">https://en.wikipedia.org/wiki/Emacs</a>
</li>

<li>Emacs timeline<br />
<a href="http://www.jwz.org/doc/emacs-timeline.html">http://www.jwz.org/doc/emacs-timeline.html</a>
</li>

<li>Emacs Text Editors Family<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?EmacsFamily">http://texteditors.org/cgi-bin/wiki.pl?EmacsFamily</a>
</li>

<li>Vrapper aneb spojení možností Vimu a Eclipse<br />
<a href="https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse/">https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse/</a>
</li>

<li>Vrapper aneb spojení možností Vimu a Eclipse (část 2: vyhledávání a nahrazování textu)<br />
<a href="https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse-cast-2-vyhledavani-a-nahrazovani-textu/">https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse-cast-2-vyhledavani-a-nahrazovani-textu/</a>
</li>

<li>Emacs/Evil-mode - A basic reference to using evil mode in Emacs<br />
<a href="http://www.aakarshnair.com/posts/emacs-evil-mode-cheatsheet">http://www.aakarshnair.com/posts/emacs-evil-mode-cheatsheet</a>
</li>

<li>From Vim to Emacs+Evil chaotic migration guide<br />
<a href="https://juanjoalvarez.net/es/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/">https://juanjoalvarez.net/es/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/</a>
</li>

<li>Introduction to evil-mode {video)<br />
<a href="https://www.youtube.com/watch?v=PeVQwYUxYEg">https://www.youtube.com/watch?v=PeVQwYUxYEg</a>
</li>

<li>EINE (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/EINE">http://www.emacswiki.org/emacs/EINE</a>
</li>

<li>EINE (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?EINE">http://texteditors.org/cgi-bin/wiki.pl?EINE</a>
</li>

<li>ZWEI (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/ZWEI">http://www.emacswiki.org/emacs/ZWEI</a>
</li>

<li>ZWEI (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?ZWEI">http://texteditors.org/cgi-bin/wiki.pl?ZWEI</a>
</li>

<li>Zmacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Zmacs">https://en.wikipedia.org/wiki/Zmacs</a>
</li>

<li>Zmacs (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?Zmacs">http://texteditors.org/cgi-bin/wiki.pl?Zmacs</a>
</li>

<li>TecoEmacs (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/TecoEmacs">http://www.emacswiki.org/emacs/TecoEmacs</a>
</li>

<li>Micro Emacs<br />
<a href="http://www.emacswiki.org/emacs/MicroEmacs">http://www.emacswiki.org/emacs/MicroEmacs</a>
</li>

<li>Micro Emacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/MicroEMACS">https://en.wikipedia.org/wiki/MicroEMACS</a>
</li>

<li>EmacsHistory<br />
<a href="http://www.emacswiki.org/emacs/EmacsHistory">http://www.emacswiki.org/emacs/EmacsHistory</a>
</li>

<li>Seznam editorů s ovládáním podobným Emacsu či kompatibilních s příkazy Emacsu<br />
<a href="http://www.finseth.com/emacs.html">http://www.finseth.com/emacs.html</a>
</li>

<li>evil-numbers<br />
<a href="https://github.com/cofi/evil-numbers">https://github.com/cofi/evil-numbers</a>
</li>

<li>Debuggery a jejich nadstavby v&nbsp;Linuxu (1.část)<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/</a>
</li>

<li>Debuggery a jejich nadstavby v&nbsp;Linuxu (2.část)<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (3): Nemiver<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (4): KDbg<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (5): ladění aplikací v editorech Emacs a Vim<br />
<a href="https://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/">https://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/</a>
</li>

<li>Org mode<br />
<a href="https://orgmode.org/">https://orgmode.org/</a>
</li>

<li>The Org Manual<br />
<a href="https://orgmode.org/manual/index.html">https://orgmode.org/manual/index.html</a>
</li>

<li>Kakoune (modální textový editor)<br />
<a href="http://kakoune.org/">http://kakoune.org/</a>
</li>

<li>Vim-style keybinding in Emacs/Evil-mode<br />
<a href="https://gist.github.com/troyp/6b4c9e1c8670200c04c16036805773d8">https://gist.github.com/troyp/6b4c9e1c8670200c04c16036805773d8</a>
</li>

<li>Emacs - jak začít<br />
<a href="http://www.abclinuxu.cz/clanky/navody/emacs-jak-zacit">http://www.abclinuxu.cz/clanky/navody/emacs-jak-zacit</a>
</li>

<li>Programovací jazyk LISP a LISP machines<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-lisp-a-lisp-machines/">https://www.root.cz/clanky/programovaci-jazyk-lisp-a-lisp-machines/</a>
</li>

<li>Evil-surround<br />
<a href="https://github.com/emacs-evil/evil-surround">https://github.com/emacs-evil/evil-surround</a>
</li>

<li>Spacemacs<br />
<a href="http://spacemacs.org/">http://spacemacs.org/</a>
</li>

<li>Lisp: Common Lisp, Racket, Clojure, Emacs Lisp<br />
<a href="http://hyperpolyglot.org/lisp">http://hyperpolyglot.org/lisp</a>
</li>

<li>Common Lisp, Scheme, Clojure, And Elisp Compared<br />
<a href="http://irreal.org/blog/?p=725">http://irreal.org/blog/?p=725</a>
</li>

<li>Does Elisp Suck?<br />
<a href="http://irreal.org/blog/?p=675">http://irreal.org/blog/?p=675</a>
</li>

<li>Emacs pro mírně pokročilé (9): Elisp<br />
<a href="https://www.root.cz/clanky/emacs-elisp/">https://www.root.cz/clanky/emacs-elisp/</a>
</li>

<li>If I want to learn lisp, are emacs and elisp a good choice?<br />
<a href="https://www.reddit.com/r/emacs/comments/2m141y/if_i_want_to_learn_lisp_are_emacs_and_elisp_a/">https://www.reddit.com/r/emacs/comments/2m141y/if_i_want_to_learn_lisp_are_emacs_and_elisp_a/</a>
</li>

<li>Clojure(Script) Interactive Development Environment that Rocks!<br />
<a href="https://github.com/clojure-emacs/cider">https://github.com/clojure-emacs/cider</a>
</li>

<li>An Introduction to Emacs Lisp<br />
<a href="https://harryrschwartz.com/2014/04/08/an-introduction-to-emacs-lisp.html">https://harryrschwartz.com/2014/04/08/an-introduction-to-emacs-lisp.html</a>
</li>

<li>Emergency Elisp<br />
<a href="http://steve-yegge.blogspot.com/2008/01/emergency-elisp.html">http://steve-yegge.blogspot.com/2008/01/emergency-elisp.html</a>
</li>

<li>Lambda calculus<br />
<a href="https://en.wikipedia.org/wiki/Lambda_calculus">https://en.wikipedia.org/wiki/Lambda_calculus</a>
</li>

<li>John McCarthy's original LISP paper from 1959<br />
<a href="https://www.reddit.com/r/programming/comments/17lpz4/john_mccarthys_original_lisp_paper_from_1959/">https://www.reddit.com/r/programming/comments/17lpz4/john_mccarthys_original_lisp_paper_from_1959/</a>
</li>

<li>Micro Manual LISP<br />
<a href="https://www.scribd.com/document/54050141/Micro-Manual-LISP">https://www.scribd.com/document/54050141/Micro-Manual-LISP</a>
</li>

<li>How Lisp Became God's Own Programming Language<br />
<a href="https://twobithistory.org/2018/10/14/lisp.html">https://twobithistory.org/2018/10/14/lisp.html</a>
</li>

<li>History of Lisp<br />
<a href="http://jmc.stanford.edu/articles/lisp/lisp.pdf">http://jmc.stanford.edu/articles/lisp/lisp.pdf</a>
</li>

<li>The Roots of Lisp<br />
<a href="http://languagelog.ldc.upenn.edu/myl/llog/jmc.pdf">http://languagelog.ldc.upenn.edu/myl/llog/jmc.pdf</a>
</li>

<li>Racket<br />
<a href="https://racket-lang.org/">https://racket-lang.org/</a>
</li>

<li>The Racket Manifesto<br />
<a href="http://felleisen.org/matthias/manifesto/">http://felleisen.org/matthias/manifesto/</a>
</li>

<li>MIT replaces Scheme with Python<br />
<a href="https://www.johndcook.com/blog/2009/03/26/mit-replaces-scheme-with-python/">https://www.johndcook.com/blog/2009/03/26/mit-replaces-scheme-with-python/</a>
</li>

<li>Adventures in Advanced Symbolic Programming<br />
<a href="http://groups.csail.mit.edu/mac/users/gjs/6.945/">http://groups.csail.mit.edu/mac/users/gjs/6.945/</a>
</li>

<li>Why MIT Switched from Scheme to Python (2009)<br />
<a href="https://news.ycombinator.com/item?id=14167453">https://news.ycombinator.com/item?id=14167453</a>
</li>

<li>Starodávná stránka XLispu<br />
<a href="http://www.xlisp.org/">http://www.xlisp.org/</a>
</li>

<li>AutoLISP<br />
<a href="https://en.wikipedia.org/wiki/AutoLISP">https://en.wikipedia.org/wiki/AutoLISP</a>
</li>

<li>Seriál PicoLisp: minimalistický a výkonný interpret Lispu<br />
<a href="https://www.root.cz/serialy/picolisp-minimalisticky-a-vykonny-interpret-lispu/">https://www.root.cz/serialy/picolisp-minimalisticky-a-vykonny-interpret-lispu/</a>
</li>

<li>Common Lisp<br />
<a href="https://common-lisp.net/">https://common-lisp.net/</a>
</li>

<li>Getting Going with Common Lisp<br />
<a href="https://cliki.net/Getting%20Started">https://cliki.net/Getting%20Started</a>
</li>

<li>Online Tutorial (Common Lisp)<br />
<a href="https://cliki.net/online%20tutorial">https://cliki.net/online%20tutorial</a>
</li>

<li>Guile Emacs<br />
<a href="https://www.emacswiki.org/emacs/GuileEmacs">https://www.emacswiki.org/emacs/GuileEmacs</a>
</li>

<li>Guile Emacs History<br />
<a href="https://www.emacswiki.org/emacs/GuileEmacsHistory">https://www.emacswiki.org/emacs/GuileEmacsHistory</a>
</li>

<li>Guile is a programming language<br />
<a href="https://www.gnu.org/software/guile/">https://www.gnu.org/software/guile/</a>
</li>

<li>MIT Scheme<br />
<a href="http://groups.csail.mit.edu/mac/projects/scheme/">http://groups.csail.mit.edu/mac/projects/scheme/</a>
</li>

<li>SIOD: Scheme in One Defun<br />
<a href="http://people.delphiforums.com/gjc//siod.html">http://people.delphiforums.com/gjc//siod.html</a>
</li>

<li>CommonLispForEmacs<br />
<a href="https://www.emacswiki.org/emacs/CommonLispForEmacs">https://www.emacswiki.org/emacs/CommonLispForEmacs</a>
</li>

<li>Elisp: print, princ, prin1, format, message<br />
<a href="http://ergoemacs.org/emacs/elisp_printing.html">http://ergoemacs.org/emacs/elisp_printing.html</a>
</li>

<li>Special Forms in Lisp<br />
<a href="http://www.nhplace.com/kent/Papers/Special-Forms.html">http://www.nhplace.com/kent/Papers/Special-Forms.html</a>
</li>

<li>Basic Building Blocks in LISP<br />
<a href="https://www.tutorialspoint.com/lisp/lisp_basic_syntax.htm">https://www.tutorialspoint.com/lisp/lisp_basic_syntax.htm</a>
</li>

<li>Introduction to LISP - University of Pittsburgh<br />
<a href="https://people.cs.pitt.edu/~milos/courses/cs2740/Lectures/LispTutorial.pdf">https://people.cs.pitt.edu/~milos/courses/cs2740/Lectures/LispTutorial.pdf</a>
</li>

<li>Why don't people use LISP<br />
<a href="https://forums.freebsd.org/threads/why-dont-people-use-lisp.24572/">https://forums.freebsd.org/threads/why-dont-people-use-lisp.24572/</a>
</li>

<li>Structured program theorem<br />
<a href="https://en.wikipedia.org/wiki/Structured_program_theorem">https://en.wikipedia.org/wiki/Structured_program_theorem</a>
</li>

<li>Clojure: API Documentation<br />
<a href="https://clojure.org/api/api">https://clojure.org/api/api</a>
</li>

<li>Tutorial for the Common Lisp Loop Macro<br />
<a href="http://www.ai.sri.com/pkarp/loop.html">http://www.ai.sri.com/pkarp/loop.html</a>
</li>

<li>Common Lisp's Loop Macro Examples for Beginners<br />
<a href="http://www.unixuser.org/~euske/doc/cl/loop.html">http://www.unixuser.org/~euske/doc/cl/loop.html</a>
</li>

<li>A modern list api for Emacs. No 'cl required.<br />
<a href="https://github.com/magnars/dash.el">https://github.com/magnars/dash.el</a>
</li>

<li>The LOOP Facility<br />
<a href="http://www.lispworks.com/documentation/HyperSpec/Body/06_a.htm">http://www.lispworks.com/documentation/HyperSpec/Body/06_a.htm</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>Transient Data Structures
<a href="http://clojure.org/transients">http://clojure.org/transients</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Clojure (na Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (na Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>SICP (The Structure and Interpretation of Computer Programs)<br />
<a href="http://mitpress.mit.edu/sicp/">http://mitpress.mit.edu/sicp/</a>
</li>

<li>Pure function<br />
<a href="http://en.wikipedia.org/wiki/Pure_function">http://en.wikipedia.org/wiki/Pure_function</a>
</li>

<li>Funkcionální programování<br />
<a href="http://cs.wikipedia.org/wiki/Funkcionální_programování">http://cs.wikipedia.org/wiki/Funkcionální_programování</a>
</li>

<li>Jazyky Hy a Clojure-py: moderní dialekty LISPu určené pro Python VM<br />
<a href="https://www.root.cz/clanky/jazyky-hy-a-clojure-py-moderni-dialekty-lispu-urcene-pro-python-vm/">https://www.root.cz/clanky/jazyky-hy-a-clojure-py-moderni-dialekty-lispu-urcene-pro-python-vm/</a>
</li>

<li>Pixie: lehký skriptovací jazyk s „kouzelnými“ schopnostmi<br />
<a href="https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/">https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/</a>
</li>

<li>Programovací jazyk Pixie: funkce ze základní knihovny a použití FFI<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/">https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/</a>
</li>

<li>Stránka projektu Jython<br />
<a href="http://www.jython.org/">http://www.jython.org/</a>
</li>

<li>Jython (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Jython">https://en.wikipedia.org/wiki/Jython</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">https://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>JSR 223: Scripting for the Java<sup>TM</sup> Platform<br />
<a href="https://jcp.org/en/jsr/detail?id=223">https://jcp.org/en/jsr/detail?id=223</a>
</li>

<li>List of JVM languages<br />
<a href="https://en.wikipedia.org/wiki/List_of_JVM_languages">https://en.wikipedia.org/wiki/List_of_JVM_languages</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

