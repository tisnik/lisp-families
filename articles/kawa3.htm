<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Zpracování vektorů, matic a N-rozměrných polí v programovacím jazyku Kawa</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Zpracování vektorů, matic a N-rozměrných polí v programovacím jazyku Kawa</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešní části seriálu o světě lispovských programovacích jazyků, si ukážeme, jakým způsobem se v jazyku Kawa pracuje s vektory a maticemi. Tato velmi důležitá oblast informatiky, která je někdy nazývána array programming, se neustále rozvíjí, což zasáhlo i jazyky postavené na LISPu (Racket, Kawa, Clojure).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Array programming a specializované programovací jazyky určené pro zpracování matic</a></p>
<p><a href="#k02">2. Zpracování vektorů a matic v&nbsp;programovacím jazyku Kawa</a></p>
<p><a href="#k03">3. Použití javovských polí v&nbsp;programovacím jazyku Kawa</a></p>
<p><a href="#k04">4. Instrukce bajtkódu JVM určené pro konstrukci polí</a></p>
<p><a href="#k05">5. Inicializace prvků polí</a></p>
<p><a href="#k06">6. Vícerozměrná javovská pole</a></p>
<p><a href="#k07">7. Vektory</a></p>
<p><a href="#k08">8. N-rozměrná pole (ND-array)</a></p>
<p><a href="#k09">9. Konstrukce N-rozměrných polí</a></p>
<p><a href="#k10">10. Inicializace prvků N-rozměrných polí</a></p>
<p><a href="#k11">11. Specifikace rozsahu (<strong>range</strong>)</a></p>
<p><a href="#k12">12. Použití rozsahu (<strong>range</strong>) pro výběr hodnot z&nbsp;vektoru</a></p>
<p><a href="#k13">13. Inicializace N-rozměrných polí s&nbsp;využitím rozsahů</a></p>
<p><a href="#k14">14. Nepravidelná N-rozměrná pole</a></p>
<p><a href="#k15">15. Malá odbočka na závěr: knihovny pro práci s&nbsp;vektory a maticemi pro programovací jazyk Clojure</a></p>
<p><a href="#k16">16. Knihovna <strong>core.matrix</strong></a></p>
<p><a href="#k17">17. Obsah následující části seriálu</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Literatura</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Array programming a specializované programovací jazyky určené pro zpracování matic</h2>

<p>Dnes se budeme zabývat jednou poměrně rozsáhlou oblastí v&nbsp;IT. Tou je
zpracování vektorů, matic a taktéž vícerozměrných polí, protože s&nbsp;těmito
strukturami se můžeme setkat v&nbsp;různých disciplínách, například ve
finančnictví, pojišťovnictví, statistice, zpracování numerických dat,
simulacích atd. Současně se jedná i o velmi zajímavou oblast, neboť právě kvůli
nutnosti co nejrychlejší práce s&nbsp;velkými maticemi byly vytvořeny speciální
výpočetní bloky v&nbsp;některých superpočítačích (příkladem mohou být
superpočítače <i>Cray</i>) a došlo tak k&nbsp;důležitému podnětu pro další
rozvoj výpočetní techniky (ten nepřímo vedl k&nbsp;vývoji moderních GPU).
Současné knihovny pro práci s&nbsp;poli dokážou v&nbsp;případě potřeby využít
jak některé rozšíření instrukčních sad (SIMD instrukce typu SSE neboli
Streaming SIMD Extensions, původně též MMX či 3DNow!), tak i programovatelné
grafické akcelerátory (GPU). SIMD instrukcemi jsme se již na stránkách Roota
zabývali v&nbsp;samostatných článcích, zejména v:</p>

<ol>

<li>SIMD instrukce využívané v moderních mikroprocesorech řady x86<br />
<a href="https://www.root.cz/clanky/simd-instrukce-vyuzivane-v-modernich-mikroprocesorech-rady-x86/">https://www.root.cz/clanky/simd-instrukce-vyuzivane-v-modernich-mikroprocesorech-rady-x86/</a>
</li>

<li>SIMD instrukce v moderních mikroprocesorech řady x86 (2.část: SSE)<br />
<a href="https://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-2-cast-sse/">https://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-2-cast-sse/</a>
</li>

<li>SIMD instrukce v moderních mikroprocesorech řady x86 (3.část: SSE2)<br />
<a href="https://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-3-cast-sse2/">https://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-3-cast-sse2/</a>
</li>

</ol>

<p>Práce s&nbsp;vektory a maticemi byla (a samozřejmě doposud je) podporována
v&nbsp;překladačích FORTRANu, které začaly být po vzniku superpočítačů vybaveny
specializovanými algoritmy, které dokázaly převést některé typy programových
smyček na &bdquo;vektorové operace&ldquo;. Paralelně vznikly i specializované
jazyky určené téměř výhradně pro práci s&nbsp;vektory i maticemi. Velmi dobrým
příkladem jsou programovací jazyky <i>APL</i> a <i>J</i>. I těmito neobvyklými
(ale stále používanými!) programovacími jazyky jsme se na stránkách Rootu již
zabývali, a to v&nbsp;následujících článcích:</p>

<ol>

<li>Programování mainframů: jazyk APL<br />
<a href="https://www.root.cz/clanky/programovani-mainframu-jazyk-apl/">https://www.root.cz/clanky/programovani-mainframu-jazyk-apl/</a>
</li>

<li>Programovací jazyk APL: programování bez smyček<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-apl-programovani-bez-smycek/">https://www.root.cz/clanky/programovaci-jazyk-apl-programovani-bez-smycek/</a>
</li>

<li>Programovací jazyk APL - dokončení<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-apl-dokonceni/">https://www.root.cz/clanky/programovaci-jazyk-apl-dokonceni/</a>
</li>

<li>Programovací jazyk J – od hieroglyfů k ASCII znakům<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-j-ndash-od-hieroglyfu-k-nbsp-ascii-znakum/">https://www.root.cz/clanky/programovaci-jazyk-j-ndash-od-hieroglyfu-k-nbsp-ascii-znakum/</a>
</li>

<li>Programujeme v jazyku J: vektory a matice<br />
<a href="https://www.root.cz/clanky/programujeme-v-jazyku-j-ndash-vektory-a-matice/">https://www.root.cz/clanky/programujeme-v-jazyku-j-ndash-vektory-a-matice/</a>
</li>

<li>Programovací jazyk J: operátory, uživatelské funkce a tacit programming<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-j-operatory-uzivatelske-funkce-a-tacit-programming/">https://www.root.cz/clanky/programovaci-jazyk-j-operatory-uzivatelske-funkce-a-tacit-programming/</a>
</li>

</ol>

<p>Velmi dobrou podporu pro práci s&nbsp;maticemi ovšem nabízí i framework <a
href="https://www.root.cz/serialy/torch-framework-pro-strojove-uceni/">Torch</a>
založený na jazyku Lua, <a
href="https://www.root.cz/serialy/programovaci-jazyk-julia/">programovací jazyk
Julia</a> a knihovna <a href="https://www.numpy.org/">Numpy</a> určená pro
programovací jazyk Python. Opět uvedu odkazy na články, v&nbsp;níž se touto
populární a velmi často používanou knihovnou zabýváme do větší hloubky, než to
umožňuje rozsah dnešního článku:</p>

<ol>

<li>Integrovaná vývojová prostředí ve Fedoře: vykreslování grafů s využitím knihoven Numpy a matplotlib<br />
<a href="https://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-vykreslovani-grafu-s-vyuzitim-knihoven-numpy-a-matplotlib/">https://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-vykreslovani-grafu-s-vyuzitim-knihoven-numpy-a-matplotlib/</a>
</li>

<li>Integrovaná vývojová prostředí ve Fedoře: praktické použití IPython Notebooku a knihovny Numpy (2.část)<br />
<a href="https://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-prakticke-pouziti-ipython-notebooku-a-knihovny-numpy-2-cast/">https://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-prakticke-pouziti-ipython-notebooku-a-knihovny-numpy-2-cast/</a>
</li>

<li>Integrovaná vývojová prostředí ve Fedoře: praktické použití IPython Notebooku a knihovny Numpy<br />
<a href="https://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-prakticke-pouziti-ipython-notebooku-a-knihovny-numpy/">https://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-prakticke-pouziti-ipython-notebooku-a-knihovny-numpy/</a>
</li>

</ol>



<p><a name="k02"></a></p>
<h2 id="k02">2. Zpracování vektorů a matic v&nbsp;programovacím jazyku Kawa</h2>

<p>V&nbsp;dnešním článku se budeme zabývat především tím, jak se matice
(prakticky libovolných rozměrů a s&nbsp;obecně více dimenzemi, tedy i vektory)
používají v&nbsp;programovacím jazyku <i>Kawa</i>, kterému jsme se podrobně
věnovali <a
href="https://www.root.cz/clanky/jazyk-kawa-v-ekosystemu-virtualniho-stroje-javy/">minule</a>
a <a
href="https://www.root.cz/clanky/kawa-prekvapive-silny-a-vykonny-dialekt-scheme-pro-jvm/">předminule</a>.
Nutno říci, že v&nbsp;této oblasti je <i>Kawa</i> v&nbsp;poněkud schizofrenní
situaci, protože pochopitelně podporuje klasické LISPovské vektory (nejedná se
sice o zcela základní datový typ, ovšem prakticky každá implementace LISPu či
Scheme práci s&nbsp;vektory umožňuje), dále podporuje N-dimenzionální pole
(<i>ND-array</i>) vycházející z&nbsp;konceptů, které se objevily <a
href="https://racket-lang.org/">v&nbsp;jazyce Racket</a>, konkrétně ve
standardním modulu <a
href="https://docs.racket-lang.org/math/array.html">math-array</a> a zapomenout
nesmíme ani na možnost použít pole kompatibilní s&nbsp;programovacím jazykem
Java a podporované přímo v&nbsp;bajtkódu JVM (viz též předchozí část tohoto
seriálu).</p>

<p>Kromě toho si na konci článku připomeneme existenci knihovny nazvané
<strong>core.matrix</strong>, která vývojářům pracujícím s&nbsp;programovacím
jazykem Clojure nabízí prakticky všechny potřebné operace, které se při práci
s&nbsp;vektory a maticemi používají (včetně například výpočtu inverzní matice).
Navíc je tato knihovna zajímavá tím, že předepisuje <i>rozhraní</i> pro všechny
operace, ovšem konkrétní implementaci je možné si vybrat. To například znamená,
že pokud je řešen nějaký problém, v&nbsp;němž se ve velké míře používají
takzvané řídké matice (pěkným příkladem z&nbsp;praxe může být <i>Google
matrix</i>), lze &ndash; beze změny uživatelského programu &ndash; vybrat
takovou reprezentaci matic a takové algoritmy, které jsou optimalizovány právě
pro práci s&nbsp;řídkými maticemi a nikoli s&nbsp;maticemi uloženými ve formě
dvourozměrného pole.</p>

<p><div class="rs-tip-major">Poznámka: část věnovaná jazyku Clojure byla
zařazena z&nbsp;toho důvodu, že jak Clojure, tak i Kawa sdílí stejný ekosystém
JVM.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Použití javovských polí v&nbsp;programovacím jazyku Kawa</h2>

<p>Nejprve si ukažme, jakým způsobem je možné v&nbsp;programovacím jazyku
<i>Kawa</i> pracovat s&nbsp;poli plně kompatibilními s&nbsp;Javou a tím pádem
samozřejmě i s&nbsp;virtuálním strojem Javy. Připomeňme si, že v&nbsp;Javě mají
pole poměrně speciální postavení, protože se jedná o kontejner, který dokáže
uložit známý počet prvků určitého typu (počet prvků musí být specifikován při
konstrukci pole). Samozřejmě je možné, aby pole obsahovalo jako své prvky další
pole, čímž je umožněno vytvářet matice i vícerozměrné datové struktury, které
navíc nemusí mít nutně obdélníkový či čtvercový tvar. Interně je pole
v&nbsp;operační paměti, přesněji řečeno na haldě (<i>heap</i>) uloženo
v&nbsp;jediném souvislém bloku, ovšem musíme si přesně uvědomit co to znamená
&ndash; pole, jehož prvky jsou primitivními datovými typy je skutečně tvořeno
souvislým blokem, ovšem pole objektů je ve skutečnosti realizováno blokem
obsahujícím <i>reference</i> popř.&nbsp;speciální hodnotu
<strong>null</strong>, zatímco vlastní objekty jsou alokovány na jiném místě
haldy a pouze odkaz (reference) na ně je uložena v&nbsp;poli.</p>

<p>Vícerozměrná pole jsou vlastně &bdquo;pole polí&ldquo; a tudíž pole
obsahující reference (což je jeden z&nbsp;poměrně zásadních rozdílů mezi Javou
a jazykem C v&nbsp;této oblasti).</p>

<p>Toto uspořádání přináší některé výhody, ale i nevýhody. Mezi výhody patří
relativně snadná práce <i>garbage collectoru</i> při přenášení pole
v&nbsp;rámci jednotlivých regionů, na něž je halda rozdělena (více viz <a
href="https://www.root.cz/clanky/monitorovani-procesu-a-sprava-pameti-v-jdk-6-a-jdk-7-2/"></a>
a navazující články) a zmenšuje se i počet tzv.&nbsp;<i>Monitorování procesů a
správa paměti v JDK 6 a JDK 7 (2)</i>, ovšem počet objektů a spotřeba operační
paměti poměrně rychle narůstá, protože velká část haldy může obsahovat pouze
reference na objekty (extrémním příkladem může být rastrový obrázek,
v&nbsp;němž jsou jednotlivé pixely realizovány instancemi třídy
<strong>Color</strong>).</p>

<p>V&nbsp;programovacím jazyku <i>Kawa</i> je umožněno vytvářet klasická
Javovská pole libovolného typu. Nejjednodušší je situace v&nbsp;případě, že se
má jednat o pole s&nbsp;prvky primitivních datových typů. Vytvoření takového
pole, zde konkrétně pole prvků typu <strong>int</strong> může vypadat
následovně:</p>

<pre>
(define array1 <strong>(int[] length: 10)</strong>)
&nbsp;
(display array1)
(newline)
</pre>

<p>S&nbsp;tímto výsledkem:</p>

<pre>
[0 0 0 0 0 0 0 0 0 0]
</pre>

<p>Samozřejmě je možné vytvořit funkci, která pole zkonstruuje a vrátí ho jako
svoji návratovou hodnotu:</p>

<pre>
(define (<strong>createArray</strong> length)
  (int[] length: length))
&nbsp;
(let ((array1 (createArray 10)))
    (display array1)
    (newline))
</pre>

<p>Výsledek:</p>

<pre>
[0 0 0 0 0 0 0 0 0 0]
</pre>

<p>Změna hodnoty prvku pole s&nbsp;využitím funkce <strong>set!</strong>:</p>

<pre>
(define array2 <strong>(int[] 1 2 3 4 5)</strong>)
&nbsp;
(display array2)
(newline)
&nbsp;
<strong>(set! (array2 2) -1)</strong>
&nbsp;
(display array2)
(newline)
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
[1 2 3 4 5]
[1 2 -1 4 5]
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že jméno funkce měnící
pole končí vykřičníkem, podobně jako další podobně koncipované funkce, které
obecně mění stav aplikace. Dále si povšimněte, že se prvky indexují od nuly,
stejně jako v&nbsp;C a Javě.</div></p>

<p>Při přístupu k&nbsp;prvkům pole se hlídá rozsah indexů:</p>

<pre>
(define array2 <strong>(int[] 1 2 3 4 5)</strong>)
&nbsp;
(display array2)
(newline)
&nbsp;
<strong>(set! (array2 100) -1)</strong>
&nbsp;
(display array2)
(newline)
</pre>

<p>Při spuštění tohoto skriptu dojde k&nbsp;vyhození výjimky naprosto stejné,
jako by tomu bylo v&nbsp;Javě:</p>

<pre>
[1 2 3 4 5]
java.lang.ArrayIndexOutOfBoundsException: 100
        at Array2_exception.run(Array2_exception.scm:4)
        at gnu.expr.ModuleExp.evalModule2(ModuleExp.java:289)
        at gnu.expr.CompiledModule.evalModule(CompiledModule.java:42)
        at gnu.expr.CompiledModule.evalModule(CompiledModule.java:60)
        at kawa.Shell.runFile(Shell.java:565)
        at kawa.Shell.runFileOrClass(Shell.java:468)
        at kawa.repl.processArgs(repl.java:700)
        at kawa.repl.main(repl.java:820)
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Instrukce bajtkódu JVM určené pro konstrukci polí</h2>

<p>Konstrukce pole a přístup k&nbsp;prvkům pole je plně podporován i bajtkódem
virtuálního stroje Javy. Zatímco objekty se vytváří s&nbsp;využitím instrukce
<strong>new</strong> a pro přístup k&nbsp;jejich atributům se používají
instrukce <strong>getfield</strong> a <strong>putfield</strong>, je situace
v&nbsp;případě polí odlišná, protože se pro pole používá dvacet
specializovaných instrukcí sloužících jak pro vytvoření pole, tak i pro přístup
k&nbsp;jeho prvkům, popř.&nbsp;pro zjištění délky pole.</p>

<p>První instrukcí, se kterou se dnes seznámíme, je instrukce nazvaná
<strong>newarray</strong>. Pravděpodobně uhodnete, k&nbsp;čemu tato instrukce
slouží &ndash; lze ji použít pro vytvoření pole dané délky, ovšem pouze
v&nbsp;tom případě, pokud má pole obsahovat prvky některého z&nbsp;primitivních
datových typů, tj.&nbsp;pravdivostní hodnoty, znaky, celá čísla či čísla
s&nbsp;plovoucí řádovou čárkou. Jinými slovy to znamená, že tuto instrukci
nelze použít například pro vytvoření pole objektů. Formát instrukce
<strong>newarray</strong> je vypsán v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operandy</th><th>Prováděná operace</th></tr>
<tr><td>1</td><td>newarray</td><td>0xBC</td><td>arraytype</td><td>Vytvoří nové pole s prvky primitivního datového typu</td></tr>
</table>

<p>Instrukce <strong>newarray</strong> očekává, že na vrcholu zásobníku
operandů (<i>TOS</i>) bude uložena hodnota typu <strong>int</strong> udávající
velikost pole. Tato hodnota je ze zásobníku v&nbsp;průběhu vytváření pole
odstraněna a namísto ní se na vrchol zásobníku operandů uloží reference na
právě vytvořené pole. Ještě nám zbývá popsat operand instrukce
<strong>newarray</strong> nazvaný <i>arraytype</i>. Jde o jednobajtový operand,
jehož hodnota určuje typ prvků vytvářeného pole. Jak jsme si již řekli
v&nbsp;předchozím odstavci, může se pomocí instrukce <strong>newarray</strong>
vytvořit pole složené z&nbsp;pravdivostních hodnot, znaků, celých čísel či
čísel s&nbsp;plovoucí řádovou čárkou (ve všech případech se jedná o primitivní
datové typy):</p>

<table>
<tr><th>Arraytype</th><th>Typ prvků pole</th></tr>
<tr><td> 4</td><td>boolean</td></tr>
<tr><td> 5</td><td>char</td></tr>
<tr><td> 6</td><td>float</td></tr>
<tr><td> 7</td><td>double</td></tr>
<tr><td> 8</td><td>byte</td></tr>
<tr><td> 9</td><td>short</td></tr>
<tr><td>10</td><td>int</td></tr>
<tr><td>11</td><td>long</td></tr>
</table>

<p>Vytvoření pole pomocí:</p>

<pre>
(int[] length: 10)
</pre>

<p>Se do bajtkódu přeloží takto:</p>

<pre>
5: bipush        10
7: newarray      int
</pre>

<p>Naproti tomu funkce pro alokaci pole:</p>

<pre>
(define (<strong>createArray</strong> length)
  (int[] length: length))
</pre>

<p>Je přeložena do bajtkódu následujícím (neefektivním) způsobem:</p>

<pre>
  public static int[] <strong>createArray</strong>(java.lang.Object);
    Code:
       0: aload_0
       1: invokestatic  #16                 // Method gnu/mapping/Promise.force:(Ljava/lang/Object;)Ljava/lang/Object;
       4: checkcast     #18                 // class java/lang/Number
       7: invokevirtual #22                 // Method java/lang/Number.intValue:()I
      10: newarray      int
      12: areturn
</pre>

<p>Lepší je použít typovou informaci o parametru <strong>length</strong>:</p>

<pre>
(define (<strong>createArray length :: int</strong>)
  (int[] length: length))
&nbsp;
(let ((array1 (createArray 10)))
    (display array1)
    (newline))
</pre>

<p>Nyní je překlad funkce <strong>createArray</strong> do bajtkódu velmi
efektivní:</p>

<pre>
  public static int[] <strong>createArray</strong>(int);
    Code:
       0: iload_0
       1: newarray   int
       3: areturn
</pre>

<p>Další instrukcí používanou při vytváření polí je instrukce nazvaná
<strong>anewarray</strong> (na začátku jména této instrukce se nachází znak
&bdquo;a&ldquo;). Tato instrukce se používá pro vytvoření pole, jehož prvky
jsou objekty, a to objekty libovolného (specifikovaného) typu. Zatímco se u
instrukce <strong>newarray</strong> specifikoval typ prvků pole pomocí hodnoty
bajtu uloženého ihned za operačním kódem instrukce, je nutné u instrukce
<strong>anewarray</strong> použít celé jméno třídy, rozhraní či výčtového typu
(udávající typ prvků pole). Toto jméno třídy je, jak pravděpodobně již tušíte,
uložené v&nbsp;<i>constant poolu</i>, takže se za operačním kódem instrukce
<strong>anewarray</strong> nachází dvojice bajtů představujících index záznamu
v&nbsp;<i>constant poolu</i>.</p>

<p>Chování obou zmíněných instrukcí však zůstává stejné &ndash; z&nbsp;vrcholu
zásobníku operandů se vyzvedne hodnota typu <i>int</i> představující velikost
pole, pole daného typu se vytvoří a následně se na zásobník operandů uloží
reference na vytvořený objekt (v&nbsp;případě polí objektů samozřejmě nejsou
tyto objekty vytvořeny a pole obsahuje hodnoty <strong>null</strong>):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Opkód</th><th>Operandy</th><th>Prováděná operace</th></tr>
<tr><td>1</td><td>anewarray</td><td>0xBD</td><td>highbyte, lowbyte</td><td>Vytvoří nové pole objektů</td></tr>
</table>

<p>Příklad použití:</p>

<pre>
(define (createStringArray length :: int)
  (<strong>String[]</strong> length: length))
&nbsp;
(let ((array1 (createStringArray 10)))
    (display array1)
    (newline))
</pre>

<p>Překlad do bajtkódu:</p>

<pre>
  public static java.lang.String[] <strong>createStringArray</strong>(int);
    Code:
       0: iload_0
       1: anewarray     #10   // class java/lang/String
       4: areturn
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Inicializace prvků polí</h2>

<p>Pole je možné při jejich konstrukci přímo i inicializovat, což je
pochopitelně podporováno i v&nbsp;programovacím jazyku <i>Kawa</i>. Konstrukce
pole s&nbsp;inicializací jeho prvků vypadá následovně:</p>

<pre>
(define array2 (<strong>int[] 1 2 3 4 5)</strong>)
&nbsp;
(display array2)
(newline)
&nbsp;
(<strong>set!</strong> (array2 2) -1)
&nbsp;
(display array2)
(newline)
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
[1 2 3 4 5]
[1 2 -1 4 5]
</pre>

<p>Ukažme si nyní nepatrně složitější příklad, v&nbsp;němž mají prvky hodnoty,
které se nepodobají indexům prvků (což by nás mátlo při studiu bajtkódu):</p>

<pre>
(define array2 (<strong>int[] 100 200 300 400 500)</strong>)
(set! (array2 2) -1)
</pre>

<p>Jak se tato zdánlivě triviální konstrukce přeloží do bajtkódu? Ukazuje se,
že nepříliš efektivně &ndash; v&nbsp;bajtkódu se nejdříve pole zkonstruuje a
následně se jednotlivé prvky inicializují samostatně, vždy několika instrukcemi
(<strong>iconst</strong>+<strong>*push</strong>+<strong>iastore</strong>) pro
každý prvek:</p>

<pre>
  public final void run(gnu.mapping.CallContext);
    Code:
       0: aload_1
       1: getfield      #8                  // Field gnu/mapping/CallContext.consumer:Lgnu/lists/Consumer;
       4: astore_2
       5: iconst_5
       6: newarray       int
       8: dup
       9: iconst_0
      10: bipush        100
      12: iastore
      13: dup
      14: iconst_1
      15: sipush        200
      18: iastore
      19: dup
      20: iconst_2
      21: sipush        300
      24: iastore
      25: dup
      26: iconst_3
      27: sipush        400
      30: iastore
      31: dup
      32: iconst_4
      33: sipush        500
      36: iastore
      37: putstatic     #12                 // Field array2:[I
      40: getstatic     #12                 // Field array2:[I
      43: iconst_2
      44: iconst_m1
      45: iastore
      46: return
</pre>

<p>Podobně lze zkonstruovat a inicializovat i pole prvků typu
<strong>float</strong>:</p>

<pre>
(define array3 (float[] 100 200 300 400 500 600 700 800 900 1000))
&nbsp;
(display array3)
(newline)
&nbsp;
(set! (array3 9) -1000)
&nbsp;
(display array3)
(newline)
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
[100.0 200.0 300.0 400.0 500.0 600.0 700.0 800.0 900.0 1000.0]
[100.0 200.0 300.0 400.0 500.0 600.0 700.0 800.0 900.0 -1000.0]
</pre>

<p>Překlad do bajtkódu JVM:</p>

<pre>
 5: bipush        10
 7: newarray       float
 9: dup
10: iconst_0  
11: bipush        100
13: i2f
14: fastore
15: dup
16: iconst_1  
17: ldc           #9                  // float 200.0f
19: fastore
20: dup
21: iconst_2  
22: ldc           #10                 // float 300.0f
24: fastore
25: dup
26: iconst_3  
27: ldc           #11                 // float 400.0f
29: fastore
30: dup
31: iconst_4  
32: ldc           #12                 // float 500.0f
34: fastore
35: dup
36: iconst_5  
37: ldc           #13                 // float 600.0f
39: fastore
40: dup
41: bipush        6
43: ldc           #14                 // float 700.0f
45: fastore
46: dup
47: bipush        7
49: ldc           #15                 // float 800.0f
51: fastore
52: dup
53: bipush        8
55: ldc           #16                 // float 900.0f
57: fastore
58: dup
59: bipush        9
61: ldc           #17                 // float 1000.0f
63: fastore
</pre>

<p><div class="rs-tip-major">Poznámka: vidíme, že nyní se každý prvek
inicializuje trojicí instrukcí <strong>iconst/bipush</strong> (načtení indexu)
+ <strong>ldc</strong> (načtení konstanty) + <strong>fastore</strong> (uložení
do pole).</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Vícerozměrná javovská pole</h2>

<p>V&nbsp;předchozím textu jsme si ukázali, jakým způsobem je možné pracovat
s&nbsp;jednorozměrnými javovskými poli libovolného typu. Ovšem programovací
jazyk <i>Kawa</i> pochopitelně podporuje i vícerozměrná pole, která je možné
zkonstruovat jediným příkazem, bez nutnosti konstruovat pole nižších dimenzí.
Celou operaci si pochopitelně ukážeme na několika demonstračních příkladech.
Nejprve vytvoření dvourozměrného pole:</p>

<pre>
(define matrix1 (<strong>int[][] [1 2 3] [4 5 6] [7 8 9])</strong>)
&nbsp;
(display matrix1)
(newline)
</pre>

<p>Po spuštění tohoto příkladu by se na standardním výstupu měl objevit obsah
matice:</p>

<pre>
[[1 2 3] [4 5 6] [7 8 9]]
</pre>

<p>Pole obsahující jako své prvky další pole, ovšem s&nbsp;různými délkami:</p>

<pre>
(define matrix2 (<strong>int[][] [1] [2 3] [4 5 6] [7 8 9 10]</strong>))
&nbsp;
(display matrix2)
(newline)
</pre>

<p>Výsledkem bude:</p>

<pre>
[[1] [2 3] [4 5 6] [7 8 9 10]]
</pre>

<p>Totéž, ovšem pro prvky typu <strong>float</strong>:</p>

<pre>
(define matrix3 (<strong>float[][] [1] [2 3] [4 5 6] [7 8 9 10]</strong>))
&nbsp;
(display matrix3)
(newline)
</pre>

<p>Výsledkem v&nbsp;tomto případě bude:</p>

<pre>
[[1.0] [2.0 3.0] [4.0 5.0 6.0] [7.0 8.0 9.0 10.0]]
</pre>

<p>Trojrozměrné pole:</p>

<pre>
(<strong>int[][][] [[1 2] [3 4]] [[5 6] [7 8]]</strong>)
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Vektory</h2>

<p>Javovská pole podporovaná v&nbsp;programovacím jazyku <i>Kawa</i> přináší
několik výhod, ale pochopitelně i nevýhod. Samotná pole mají pevnou délku a
jejich prvky jsou vždy stejného typu. Tato vlastnost (výhoda a nevýhoda
současně) umožňuje velmi efektivní přístup k&nbsp;prvkům pole, který má u
jednorozměrných polí konstantní složitost. Současně jsme však omezeni například
tím, že do javovských polí není možné jednoduše ukládat zlomky, celá čísla
s&nbsp;libovolným rozsahem atd. V&nbsp;případě, že budeme potřebovat i tuto
funkcionalitu, je nutné namísto polí použít odlišné datové typy programovacího
jazyka <i>Kawa</i>. Může se jednat o <i>vektory</i> podporované v&nbsp;mnoha
implementacích LISPu i Scheme (a taktéž v&nbsp;jazyku Clojure, i když zde mají
vektory zcela odlišné vnitřní uspořádání) nebo o typ pojmenovaný pro větší
zmatek v&nbsp;terminologii <i>array</i>.</p>

<p>V&nbsp;této kapitole si ukážeme práci s&nbsp;takzvanými vektory.</p>

<table>
<tr><th>#</th><th>Funkce</th><th>Stručný popis funkce</th></tr>
<tr><td>1</td><td>vector</td><td>konstrukce vektoru a inicializace jeho prvků</td></tr>
<tr><td>2</td><td>vector-ref</td><td>přístup k&nbsp;prvku vektoru</td></tr>
<tr><td>3</td><td>vector-set!</td><td>změna hodnoty prvku vektoru</td></tr>
<tr><td>4</td><td>vector?</td><td>predikát: dotaz, zda je předaná hodnota typu vektor či nikoli</td></tr>
<tr><td>5</td><td>vector-length</td><td>vrací délku vektoru, tedy počet jeho prvků</td></tr>
<tr><td>6</td><td>vector-&gt;list</td><td>převod vektoru na seznam</td></tr>
<tr><td>7</td><td>list-&gt;vector</td><td>opačný převod</td></tr>
</table>

<p>Vektor lze zkonstruovat speciálním &bdquo;konstruktorem&ldquo;, v&nbsp;němž
se jednotlivé prvky vektoru zapisují do hranatých závorek (což již známe
z&nbsp;programovacího jazyka Clojure). K&nbsp;prvkům vektoru se přistupuje
funkcí <strong>vector-ref</strong>:</p>

<pre>
(define vector1 <strong>[1 2 3 4]</strong>)
&nbsp;
(display vector1)
(newline)
&nbsp;
(display (<strong>vector-ref</strong> vector1 0))
(display (<strong>vector-ref</strong> vector1 10))
</pre>

<p>Výsledek:</p>

<pre>
#(1 2 3 4)
java.lang.ArrayIndexOutOfBoundsException: 10
        at gnu.lists.FVector.get(FVector.java:105)
        at kawa.lib.vectors.vectorRef(vectors.scm:21)
        at Vectors1.run(Vectors1.scm:7)
        at gnu.expr.ModuleExp.evalModule2(ModuleExp.java:289)
        at gnu.expr.CompiledModule.evalModule(CompiledModule.java:42)
        at gnu.expr.CompiledModule.evalModule(CompiledModule.java:60)
        at kawa.Shell.runFile(Shell.java:565)
        at kawa.Shell.runFileOrClass(Shell.java:468)
        at kawa.repl.processArgs(repl.java:700)
        at kawa.repl.main(repl.java:820)
</pre>

<p><div class="rs-tip-major">Poznámka: chyba nastala při přístupu k&nbsp;prvku
s&nbsp;indexem 10, který ve čtyřprvkovém vektoru pochopitelně
neexistuje.</div></p>

<p>Vektory lze taktéž zapsat stylem <strong>#()</strong>, který je kompatibilní
s&nbsp;R7RS:</p>

<pre>
#|kawa:1|# <strong>#(1 2 3)</strong>
#(1 2 3)
&nbsp;
#|kawa:2|# <strong>[1 2 3]</strong>
#(1 2 3)
&nbsp;
#|kawa:3|# <strong>(eq? #(1 2 3) [1 2 3])</strong>
#f
&nbsp;
#|kawa:4|# <strong>(equal? #(1 2 3) [1 2 3])</strong>
#t
</pre>

<p>V&nbsp;dalším příkladu je namísto zápisu prvků vektoru do hranatých závorek
použit konstruktor představovaný funkcí nazvanou jednoduše
<strong>vector</strong>. Taktéž je zde ukázána změna hodnoty vybraného prvku
s&nbsp;využitím funkce <strong>vector-set!</strong> (tato funkce opět obsahuje
ve svém jménu vykřičník, protože mění stav aplikace):</p>

<pre>
(define vector2 (<strong>vector 1 2 3 4 5</strong>))
&nbsp;
(display vector2)
(newline)
&nbsp;
(display (<strong>vector-ref</strong> vector2 0))
(newline)
&nbsp;
(<strong>vector-set!</strong> vector2 2 -1)
&nbsp;
(display vector2)
(newline)
</pre>

<p>Výsledek:</p>

<pre>
#(1 2 3 4 5)
1
#(1 2 -1 4 5)
</pre>

<p>Dotazy, zda je daná hodnota vektorem či nikoli, používají predikát
<strong>vector?</strong>:</p>

<pre>
#|kawa:25|# <strong>(vector? "A")</strong>
#f
&nbsp;
#|kawa:26|# <strong>(vector? [1 2 3])</strong>
#t
&nbsp;
#|kawa:27|# <strong>(vector? '(1 2 3))</strong>
#f
</pre>

<p>Další funkce je určena pro získání velikosti vektoru, tedy počtu jeho
prvků:</p>

<pre>
#|kawa:28|# <strong>(vector-length [1 2 3])</strong>
3
&nbsp;
#|kawa:29|# <strong>(vector-length [])</strong>
0
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. N-rozměrná pole (ND-Array)</h2>

<p>V&nbsp;navazujících kapitolách se seznámíme s&nbsp;možnostmi typu
<i>array</i>, což je datový typ představující N-rozměrná pole. Kromě toho si
ukážeme i práci s&nbsp;takzvanými &bdquo;rozsahy&ldquo; (<i>range</i>), které
do značné míry s&nbsp;poli souvisí.</p>

<p>Datový typ <i>array</i> se používá nejenom v&nbsp;jazyce <i>Kawa</i>, ale
například i v&nbsp;programovacím jazyce <i>Racket</i>, s&nbsp;nímž se seznámíme
v&nbsp;navazujících částech tohoto seriálu (jedná se pravděpodobně o
nejrozsáhlejší a nejúplnější implementaci Scheme vůbec). Samotné pole se skládá
ze dvou částí: hodnot jednotlivých prvků a tvaru pole neboli <i>shape</i>. Tvar
pole je důležitou strukturou, protože (nepřímo) určuje, jakým způsobem jsou
prvky v&nbsp;poli uspořádány. To však není vše, protože je možné jednoduše tvar
pole změnit a tím pádem prvky zdánlivě zpřeházet (interně se ovšem
v&nbsp;operační paměti s&nbsp;prvky v&nbsp;některých případech manipulovat
nemusí). Další důležitou vlastností datového typu <i>array</i> je možnost
uložit do pole libovolné hodnoty; jedná se tedy o heterogenní kontejner, na
rozdíl od běžných javovských polí.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Konstrukce N-rozměrných polí</h2>

<p>Ke konstrukci N-rozměrného pole slouží funkce nazvaná
<strong>make-array</strong>. Této funkci se předává vektor obsahující velikosti
(rozsah indexů) N-rozměrného pole ve všech dimenzích. Počet prvků tohoto
vektoru tedy odpovídá počtu dimenzí. Dále je možné této funkci předat i hodnoty
jednotlivých prvků, což si ukážeme <a href="#k10">v&nbsp;navazující
kapitole</a>. Funkci <strong>make-array</strong> si můžeme velmi snadno
otestovat v&nbsp;interaktivní smyčce REPL programovacího jazyka Kawa.</p>

<p>Mezní případ &ndash; prázdné pole:</p>

<pre>
#|kawa:3|# <strong>(make-array [0])</strong>
&nbsp;
#()
</pre>

<p>Konstrukce jednoprvkového jednorozměrné pole:</p>

<pre>
#|kawa:8|# <strong>(make-array [1])</strong>
&nbsp;
#(#!null)
</pre>

<p>Desetiprvkový vektor:</p>

<pre>
#|kawa:5|# <strong>(make-array [10])</strong>
&nbsp;
#(#!null #!null #!null #!null #!null #!null #!null #!null #!null #!null)
</pre>

<p>Konstrukce matice 1&times;1 s&nbsp;jediným prvkem:</p>

<pre>
#|kawa:9|# <strong>(make-array [1 1])</strong>
&nbsp;
╔#2a:1:1
║#!null║
╚══════╝
</pre>

<p>Konstrukce matice s&nbsp;jedním řádkem a dvěma sloupci:</p>

<pre>
#|kawa:7|# <strong>(make-array [1 2])</strong>
&nbsp;
╔#2a:1:2══════╗
║#!null│#!null║
╚══════╧══════╝
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, jakým způsobem interpret
programovacího jazyka <i>Kawa</i> zobrazuje obsah zkonstruovaného pole. U
jednorozměrných a dvourozměrných polí zobrazuje tabulku s&nbsp;obsahem
jednotlivých prvků, přičemž je na prvním řádku upřesněn jak počet dimenzí, tak
i rozsah indexů v&nbsp;jednotlivých dimenzích (zde konkrétně počet řádků
oddělený od počtu sloupců dvojtečkou).</div></p>

<p>Konstrukce matice se dvěma řádky a třemi sloupci:</p>

<pre>
#|kawa:10|# <strong>(make-array [2 3])</strong>
&nbsp;
╔#2a:2:3══════╤══════╗
║#!null│#!null│#!null║
╟──────┼──────┼──────╢
║#!null│#!null│#!null║
╚══════╧══════╧══════╝
</pre>

<p>Trojrozměrná struktura 2&times;3&times;4 prvky:</p>

<pre>
#|kawa:11|# <strong>(make-array [2 3 4])</strong>
&nbsp;
╔#3a:2:3:4════╤══════╤══════╗
║#!null│#!null│#!null│#!null║
╟──────┼──────┼──────┼──────╢
║#!null│#!null│#!null│#!null║
╟──────┼──────┼──────┼──────╢
║#!null│#!null│#!null│#!null║
╠══════╪══════╪══════╪══════╣
║#!null│#!null│#!null│#!null║
╟──────┼──────┼──────┼──────╢
║#!null│#!null│#!null│#!null║
╟──────┼──────┼──────┼──────╢
║#!null│#!null│#!null│#!null║
╚══════╧══════╧══════╧══════╝
</pre>

<p><div class="rs-tip-major">Poznámka: u trojrozměrné a taktéž u vícerozměrných
struktur je již nutné použít oddělovač jednotlivých 2D podmatic tak, jak je to
ukázáno na předchozím výstupu z&nbsp;interpretru programovacího jazyka
<i>Kawa</i>. Podrobnější informace najdete na stránce <a
href="https://www.gnu.org/software/guile/manual/html_node/Array-Syntax.html">https://www.gnu.org/software/guile/manual/html_node/Array-Syntax.html</a>.</div></p>

<p>Taktéž trojrozměrná struktura, ovšem tentokrát s&nbsp;tvarem
4&times;3&times;2 prvky:</p>

<pre>
#|kawa:12|# <strong>(make-array [4 3 2])</strong>
&nbsp;
╔#3a:4:3:2════╗
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╠══════╪══════╣
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╠══════╪══════╣
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╠══════╪══════╣
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╚══════╧══════╝
</pre>

<p>Čtyřrozměrné pole:</p>

<pre>
#|kawa:7|# <strong>(make-array [2 2 2 2])</strong>
&nbsp;
╔#4a:2:2:2:2══╗
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╠══════╪══════╣
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╠══════╪══════╣
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╠══════╪══════╣
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╚══════╧══════╝
</pre>

<p>Pole, které má v&nbsp;jedné dimenzi nulovou velikost a celkově tedy nula
prvků:</p>

<pre>
#|kawa:11|# <strong>(make-array [0 2 2 2])</strong>
&nbsp;
#4a:0:2:2:2 ()
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Inicializace prvků N-rozměrných polí</h2>

<p>Funkci <strong>make-arrray</strong>, s&nbsp;jejím základním použitím jsme se
seznámili <a href="#k08">v&nbsp;předchozí kapitole</a>, je možné předat i
hodnoty jednotlivých prvků vytvářeného pole. Pokud je počet zadaných hodnot
menší než počet prvků, budou se prvky opakovat tak dlouho, až se pole postupně
vyplní. Samozřejmě se opět podíváme na příklady.</p>

<p>Vektor obsahující stejné hodnoty ve všech prvcích:</p>

<pre>
#|kawa:13|# <strong>(make-array [10] 1/2)</strong>
&nbsp;
#(1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2)
</pre>

<p>Dvourozměrné pole (matice) se dvěma řádky a čtyřmi sloupci:</p>

<pre>
#|kawa:1|# <strong>(make-array [2 4] 1 2 3 4 5)</strong>
&nbsp;
╔#2a:2:4╗
║1│2│3│4║
╟─┼─┼─┼─╢
║5│1│2│3║
╚═╧═╧═╧═╝
</pre>

<p>Pole 5&times;5 prvků se shodnými řádky:</p>

<pre>
#|kawa:14|# <strong>(make-array [5 5] 1 2 3 4 5)</strong>
&nbsp;
╔#2a:5:5╤═╗
║1│2│3│4│5║
╟─┼─┼─┼─┼─╢
║1│2│3│4│5║
╟─┼─┼─┼─┼─╢
║1│2│3│4│5║
╟─┼─┼─┼─┼─╢
║1│2│3│4│5║
╟─┼─┼─┼─┼─╢
║1│2│3│4│5║
╚═╧═╧═╧═╧═╝
</pre>

<p>Trojrozměrné pole 2&times;3&times;4 prvky:</p>

<pre>
#|kawa:2|# <strong>(make-array [2 3 4] 1 2 3 4 5)</strong>
&nbsp;
#3a:2:3:4
║1│2│3│4║
╟─┼─┼─┼─╢
║5│1│2│3║
╟─┼─┼─┼─╢
║4│5│1│2║
╠═╪═╪═╪═╣
║3│4│5│1║
╟─┼─┼─┼─╢
║2│3│4│5║
╟─┼─┼─┼─╢
║1│2│3│4║
╚═╧═╧═╧═╝
</pre>

<p>Čtyřrozměrné pole 2&times;2&times;2&times;3 prvky:</p>

<pre>
#|kawa:11|# <strong>(make-array [2 2 2 3] 1 2 3)</strong>
&nbsp;
#4a═╤═╗
║1│2│3║
╟─┼─┼─╢
║1│2│3║
╠═╪═╪═╣
║1│2│3║
╟─┼─┼─╢
║1│2│3║
╠═╪═╪═╣
║1│2│3║
╟─┼─┼─╢
║1│2│3║
╠═╪═╪═╣
║1│2│3║
╟─┼─┼─╢
║1│2│3║
╚═╧═╧═╝
</pre>

<p>Pole obsahující symboly:</p>

<pre>
#|kawa:23|# <strong>(make-array [3 3 3] 'x 'y 'z)</strong>
&nbsp;
#3a═╤═╗
║x│y│z║
╟─┼─┼─╢
║x│y│z║
╟─┼─┼─╢
║x│y│z║
╠═╪═╪═╣
║x│y│z║
╟─┼─┼─╢
║x│y│z║
╟─┼─┼─╢
║x│y│z║
╠═╪═╪═╣
║x│y│z║
╟─┼─┼─╢
║x│y│z║
╟─┼─┼─╢
║x│y│z║
╚═╧═╧═╝
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Specifikace rozsahu (<strong>range</strong>)</h2>

<p>V&nbsp;jedenácté kapitole se seznámíme s&nbsp;velmi užitečným konceptem
takzvaných <i>rozsahů</i> neboli <i>range</i>. Jedná se o jeden ze způsobů,
jakým lze v&nbsp;programovacím jazyku <i>Kawa</i> popsat sekvenci hodnot bez
toho, aby bylo nutné explicitně vypsat všechny prvky v&nbsp;sekvenci (a navíc
může být zápis názornější, než v&nbsp;případě použití funkce
<strong>range</strong> známé z&nbsp;mnoha jiných programovacích jazyků).
Nejnázornější bude si ukázat možnosti, které při specifikaci rozsahů máme.</p>

<p>Hodnoty od 1 do 9 (hodnota 10 již v&nbsp;rozsahu není):</p>

<pre>
#|kawa:1|# <strong>[1 &lt;: 10]</strong>
&nbsp;
#(1 2 3 4 5 6 7 8 9)
</pre>

<p>Hodnoty od 1 do 10, včetně obou mezí:</p>

<pre>
#|kawa:2|# <strong>[1 &lt;=: 10]</strong>
&nbsp;
#(1 2 3 4 5 6 7 8 9 10)
</pre>

<p>Počítání směrem k&nbsp;záporné ose (bez uvedení kroku):</p>

<pre>
#|kawa:3|# <strong>[10 &gt;: 0]</strong>
&nbsp;
#(10 9 8 7 6 5 4 3 2 1)
</pre>

<p>Dtto, ale včetně nuly:</p>

<pre>
#|kawa:5|# <strong>[10 &gt;=: 0]</strong>
&nbsp;
#(10 9 8 7 6 5 4 3 2 1 0)
</pre>

<p>Specifikace kroku:</p>

<pre>
#|kawa:4|# <strong>[10 by: -2 >: 0]</strong>
&nbsp;
#(10 8 6 4 2)
</pre>

<p>Dtto, ale včetně nuly:</p>

<pre>
#|kawa:6|# <strong>[10 by: -2 &gt;=: 0]</strong>
&nbsp;
#(10 8 6 4 2 0)
</pre>

<p>Práce se zlomky:</p>

<pre>
#|kawa:7|# <strong>[1 by: 1/2 &lt;=: 10]</strong>
&nbsp;
#(1 3/2 2 5/2 3 7/2 4 9/2 5 11/2 6 13/2 7 15/2 8 17/2 9 19/2 10)
</pre>

<p>Počítání po 1/10 (což v&nbsp;IEEE 754 není možné):</p>

<pre>
#|kawa:8|# <strong>[0 by: 1/10 &lt;=: 1]</strong>
&nbsp;
#(0 1/10 1/5 3/10 2/5 1/2 3/5 7/10 4/5 9/10 1)
</pre>

<p>Výsledkem bude prázdný vektor:</p>

<pre>
#|kawa:14|# <strong>[0 by: 1 &lt;=: -1]</strong>
&nbsp;
#()
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Použití rozsahu (<strong>range</strong>) pro výběr hodnot z&nbsp;vektoru</h2>

<p>Rozsahy je možné použít i pro indexaci (výběr) většího množství hodnot
z&nbsp;vektoru či z&nbsp;jiné datové struktury podporující indexaci. Ukážeme si
to na příkladu řetězce obsahujícího všechny znaky malé abecedy:</p>

<pre>
#|kawa:17|# <strong>(define abeceda "abcdefghijklmnopqrstuvwxyz")</strong>
</pre>

<p>Výběr pátého až desátého znaku:</p>

<pre>
#|kawa:18|# <strong>(abeceda [5 &lt;=: 10])</strong>
&nbsp;
fghijk
</pre>

<p>Výběr pátého až desátého znaku, ovšem s&nbsp;přeskočením sudých znaků:</p>

<pre>
#|kawa:19|# <strong>(abeceda [5 by: 2 &lt;=: 10])</strong>
&nbsp;
fhj
</pre>

<p>Výběr znaků pozpátku:</p>

<pre>
#|kawa:20|# <strong>(abeceda [20 &gt;=: 5])</strong>
&nbsp;
utsrqponmlkjihgf
</pre>

<p>Celá abeceda, ovšem vybraná pozpátku:</p>

<pre>
#|kawa:21|# <strong>(abeceda [25 &gt;=: 0])</strong>
&nbsp;
zyxwvutsrqponmlkjihgfedcba
</pre>

<p>Celá abeceda:</p>

<pre>
#|kawa:22|# <strong>(abeceda [&lt;:])</strong>
&nbsp;
abcdefghijklmnopqrstuvwxyz
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Inicializace N-rozměrných polí s&nbsp;využitím rozsahů</h2>

<p>Rozsahy popsané v&nbsp;předchozí kapitole nám umožňují vytvořit pole
s&nbsp;libovolným počtem rozměrů, ve kterých se budou vyskytovat sekvence
hodnot. V&nbsp;tomto případě použijeme funkci <strong>index-array</strong>
umožňující inicializaci pole takovým způsobem, že každý prvek bude obsahovat
svůj index:</p>

<pre>
#|kawa:2|# <strong>(index-array [[1 &lt;: 10]])</strong>
&nbsp;
╔#1a@1:9╤═╤═╤═╤═╤═╗
║0│1│2│3│4│5│6│7│8║
╚═╧═╧═╧═╧═╧═╧═╧═╧═╝
</pre>

<p>Popř.:</p>

<pre>
#|kawa:3|# <strong>(index-array [[1 &lt;=: 10]])</strong>
╔#1a@1:10═╤═╤═╤═╤═╤═╗
║0│1│2│3│4│5│6│7│8│9║
╚═╧═╧═╧═╧═╧═╧═╧═╧═╧═╝
</pre>

<p>Dvourozměrné pole:</p>

<pre>
#|kawa:3|# <strong>(index-array [[1 &lt;: 3] [2 &lt;: 6]])</strong>
&nbsp;
#2a@1:2@2:4
║0│1│2│3║
╟─┼─┼─┼─╢
║4│5│6│7║
╚═╧═╧═╧═╝
</pre>

<p>Trojrozměrné pole:</p>

<pre>
#|kawa:5|# <strong>(index-array [[1 &lt;: 4] [1 &lt;: 4] [1 &lt;: 4]])</strong>
&nbsp;
#3a@1:3@1:3@1:3
║ 0│ 1│ 2║
╟──┼──┼──╢
║ 3│ 4│ 5║
╟──┼──┼──╢
║ 6│ 7│ 8║
╠══╪══╪══╣
║ 9│10│11║
╟──┼──┼──╢
║12│13│14║
╟──┼──┼──╢
║15│16│17║
╠══╪══╪══╣
║18│19│20║
╟──┼──┼──╢
║21│22│23║
╟──┼──┼──╢
║24│25│26║
╚══╧══╧══╝
</pre>

<p>Odlišný spodní index:</p>

<pre>
#|kawa:12|# <strong>(index-array [[3 &lt;: 7] [3 &lt;: 7] [3 &lt;: 7]])</strong>
&nbsp;
#3a@3:4@3:4@3:4
║ 0│ 1│ 2│ 3║
╟──┼──┼──┼──╢
║ 4│ 5│ 6│ 7║
╟──┼──┼──┼──╢
║ 8│ 9│10│11║
╟──┼──┼──┼──╢
║12│13│14│15║
╠══╪══╪══╪══╣
║16│17│18│19║
╟──┼──┼──┼──╢
║20│21│22│23║
╟──┼──┼──┼──╢
║24│25│26│27║
╟──┼──┼──┼──╢
║28│29│30│31║
╠══╪══╪══╪══╣
║32│33│34│35║
╟──┼──┼──┼──╢
║36│37│38│39║
╟──┼──┼──┼──╢
║40│41│42│43║
╟──┼──┼──┼──╢
║44│45│46│47║
╠══╪══╪══╪══╣
║48│49│50│51║
╟──┼──┼──┼──╢
║52│53│54│55║
╟──┼──┼──┼──╢
║56│57│58│59║
╟──┼──┼──┼──╢
║60│61│62│63║
╚══╧══╧══╧══╝
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Nepravidelná N-rozměrná pole</h2>

<p>V&nbsp;programovacím jazyku <i>Kawa</i> mohou být prvky N-rozměrných polí
libovolného typu. Může se jednat i o další pole atd. Ukažme si tuto možnost na
několika demonstračních příkladech.</p>

<pre>
<strong>(make-array [2 3]
    (make-array [2 2] 1/2)
    42
    "foobar"
    [1 2 3 4]
    (make-array
    [4 1] 0)
    (make-array [5 5] 'x))</strong>
&nbsp;
╔#2a:2:3══╤═══╤═════════════╗
║╔#2a:2:2╗│ 42│╔#1a:6╤═╤═╤═╗║
║║1/2│1/2║│   │║f│o│o│b│a│r║║
║╟───┼───╢│   │╚═╧═╧═╧═╧═╧═╝║
║║1/2│1/2║│   │             ║
║╚═══╧═══╝│   │             ║
╟─────────┼───┼─────────────╢
║╔#1a:4╤═╗│#2a│╔#2a:5:5╤═╗  ║
║║1│2│3│4║│║0║│║x│x│x│x│x║  ║
║╚═╧═╧═╧═╝│╟─╢│╟─┼─┼─┼─┼─╢  ║
║         │║0║│║x│x│x│x│x║  ║
║         │╟─╢│╟─┼─┼─┼─┼─╢  ║
║         │║0║│║x│x│x│x│x║  ║
║         │╟─╢│╟─┼─┼─┼─┼─╢  ║
║         │║0║│║x│x│x│x│x║  ║
║         │╚═╝│╟─┼─┼─┼─┼─╢  ║
║         │   │║x│x│x│x│x║  ║
║         │   │╚═╧═╧═╧═╧═╝  ║
╚═════════╧═══╧═════════════╝
</pre>

<p>V&nbsp;dalším příkladu je vytvořena matice se dvěma řádky a třemi sloupci.
Prvky této matice jsou další matice (2&times;2 prvky atd.) i číselné hodnoty
nebo vektory:</p>

<pre>
#|kawa:52|# <strong>(array [2 3]
    #2a((1 2) (3 4))
    9
    #2a((3 4) (5 6))
    [42 43]
    #2a:1:3((8 7 6))
    #2a((90 91) (100 101)))</strong>
&nbsp;
╔#2a:2:3╤═══════╤═════════╗
║#2a═╗  │      9│#2a═╗    ║
║║1│2║  │       │║3│4║    ║
║╟─┼─╢  │       │╟─┼─╢    ║
║║3│4║  │       │║5│6║    ║
║╚═╧═╝  │       │╚═╧═╝    ║
╟───────┼───────┼─────────╢
║╔#1a:2╗│#2a:1:3│╔#2a:2:2╗║
║║42│43║│║8│7│6║│║ 90│ 91║║
║╚══╧══╝│╚═╧═╧═╝│╟───┼───╢║
║       │       │║100│101║║
║       │       │╚═══╧═══╝║
╚═══════╧═══════╧═════════╝
</pre>

<p>Následující příklad byl převzat z&nbsp;oficiální dokumentace a byl pouze
nepatrně upraven pro větší čitelnost:</p>

<pre>
#|kawa:17|# <strong>(array [[1 &lt;=: 2] [1 &lt;=: 3]]
&nbsp;
    #2a((1 2)
    (3 4))
    9
    #2a((3 4) (5 6))
    [42 43]
    #2a:1:3((8 7 6))
    #2a((90 91) (100 101)))</strong>
&nbsp;
╔#2a@1:2@1:3════╤═════════╗
║#2a═╗  │      9│#2a═╗    ║
║║1│2║  │       │║3│4║    ║
║╟─┼─╢  │       │╟─┼─╢    ║
║║3│4║  │       │║5│6║    ║
║╚═╧═╝  │       │╚═╧═╝    ║
╟───────┼───────┼─────────╢
║╔#1a:2╗│#2a:1:3│╔#2a:2:2╗║
║║42│43║│║8│7│6║│║ 90│ 91║║
║╚══╧══╝│╚═╧═╧═╝│╟───┼───╢║
║       │       │║100│101║║
║       │       │╚═══╧═══╝║
╚═══════╧═══════╧═════════╝
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Malá odbočka na závěr: knihovny pro práci s&nbsp;vektory a maticemi pro programovací jazyk Clojure</h2>

<p>Pojďme si nyní alespoň ve stručnosti připomenout, jakým způsobem je práce
s&nbsp;maticemi podporována v&nbsp;programovacím jazyku <i>Clojure</i>, protože
Clojure do určité míry obsazuje stejný segment, jako dnes popisovaný
programovací jazyk Kawa. Při studiu základních knihoven Clojure je možné dojít
k&nbsp;závěru, že vlastně jen velmi málo funkcí a maker je určeno pro práci
s&nbsp;těmito datovými typy, i když je samozřejmě možné jak vektory, tak i
matice velmi snadno reprezentovat s&nbsp;využitím základních sekvenčních
datových struktur Clojure &ndash; seznamů a vektorů. Ve skutečnosti to však
není zcela ideální řešení, a to hned z&nbsp;několika důvodů, jejichž společným
rysem je rychlost prováděných operací a do určité míry i nároky na operační
paměť.</p>

<p>Z&nbsp;tohoto důvodu je v&nbsp;případě implementace algoritmů, v&nbsp;nichž
se intenzivně používají operace s&nbsp;maticemi, mnohem výhodnější využít
možností nabízených specializovanými knihovnami. My se dnes seznámíme především
s&nbsp;elegantně navrženou knihovnou <strong>core.matrix</strong>. Existují
ovšem ještě výkonnější řešení: knihovna <i>Neanderthal</i>, která využívá
vysoce optimalizovanou nativní knihovnu <i>ATLAS (Automatically Tuned Linear
Algebra Software)</i> s&nbsp;možností využití vysokého výpočetního výkonu
současných GPU.</p>

<p>V&nbsp;přednášce nazvané velmi příhodně &bdquo;Enter the Matrix&ldquo;,
která je dostupná na adrese <a
href="http://www.slideshare.net/mikeranderson/2013-1114-enter-thematrix">http://www.slideshare.net/mikeranderson/2013-1114-enter-thematrix</a>,
je mj.&nbsp;ukázáno, jakým způsobem jsou v&nbsp;Clojure implementována různá
paradigmata programování. Díky podpoře maker a způsobu zápisu programového kódu
v&nbsp;Clojure lze velmi snadno implementovat různé doménově specifické jazyky
(DSL), mj.&nbsp;i právě jazyk pro <i>array programming</i> (viz též <a
href="#k01">úvodní kapitolu dnešního článku</a>):</p>

<table>
<tr><th>Paradigma</th><th>Jazyk</th><th>Implementace v&nbsp;Clojure</th></tr>
<tr><td>funkcionální</td><td>Haskell</td><td>clojure.core</td></tr>
<tr><td>OOP</td><td>Smalltalk</td><td>clojure.core</td></tr>
<tr><td>metaprogramování</td><td>Lisp</td><td>clojure.core</td></tr>
<tr><td>logické</td><td>Prolog</td><td>core.logic</td></tr>
<tr><td>array programming</td><td>APL, J</td><td>core.matrix</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: původní tabulka byla upravena a
doplněna.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Knihovna <strong>core.matrix</strong></h2>

<p>V&nbsp;dalším textu se budeme zabývat knihovnou nazvanou
<strong>core.matrix</strong>, která je určena těm vývojářům, kteří ve svých
projektech potřebují provádět velké množství operací s&nbsp;těmito strukturami,
a to na poměrně vysoké úrovni, tj.&nbsp;bez nutnosti přesně specifikovat, jak
mají být matice uloženy v&nbsp;paměti, jakým způsobem provádět operaci násobení
matic atd. Díky tomuto přístupu a taktéž díky vlastnostem programovacího jazyka
<i>Clojure</i> (existence tzv.&nbsp;threading makra a funkcí vyššího řádu) se
práce s&nbsp;maticemi do značné míry začíná podobat práci v&nbsp;APL, až na ten
rozdíl, že algoritmy zapisované v&nbsp;<i>Clojure</i> jsou pro většinu vývojářů
přece jen čitelnější :-). Důležité je, že <i>rozhraní</i> definované
v&nbsp;knihovně <strong>core.matrix</strong> může mít několik implementací.
V&nbsp;současnosti se jedná o <i>vectorz-clj</i>, <i>Clatrix</i> a
<i>NDArray</i>. V&nbsp;<strong>core.matrix</strong> navíc došlo
k&nbsp;rozšíření operátorů +, - atd. takovým způsobem, že je lze použít i pro
zpracování vektorů a matic (ve skutečnosti se samozřejmě nejedná o skutečné
operátory, protože tento koncept <i>Clojure</i> a vlastně ani žádný další
lispovský jazyk nepotřebuje).</p>

<p>Funkce a makra nabízená knihovnou <strong>core.matrix</strong> nejlépe
prozkoumáme přímo s&nbsp;využitím REPLu, tj.&nbsp;interaktivního rozhraní,
v&nbsp;němž ihned po zadání dochází k&nbsp;expanzi maker a vyhodnocování
funkcí:</p>

<h3>Konstrukce vektorů a matic</h3>

<pre>
<i>; vektor</i>
matrixtest.core=&gt; <strong>(matrix [1 2 3])</strong>
[1 2 3]
&nbsp;
<i>; vektor</i>
matrixtest.core=&gt; <strong>(matrix '(1 2 3))</strong>
[1 2 3]
&nbsp;
<i>; matice</i>
matrixtest.core=&gt; <strong>(matrix [[1 2] [3 4]])</strong>
[[1 2] [3 4]]
&nbsp;
<i>; matice</i>
matrixtest.core=&gt; <strong>(matrix (range 1 10))</strong>
[1 2 3 4 5 6 7 8 9]
&nbsp;
<i>; matice</i>
matrixtest.core=&gt; <strong>(matrix [[1 2 3] [4 5 6] [7 8 9]])</strong>
[[1 2 3] [4 5 6] [7 8 9]]
</pre>

<h3>Pretty printing matic a vektorů</h3>

<pre>
matrixtest.core=&gt; <strong>(pm (matrix [[1 2] [3 4]]))</strong>
[[1.000 2.000]
 [3.000 4.000]]
&nbsp;
matrixtest.core=&gt; <strong>(matrix [[1 2] [3 4]])</strong>
[[1 2] [3 4]]
&nbsp;
<i>; *1 obsahuje výsledek poslední vyhodnocené funkce či symbolu</i>
matrixtest.core=&gt; <strong>(pm *1)</strong>
[[1.000 2.000]
 [3.000 4.000]]
</pre>

<h3>Konstruktory nulové matice a jednotkové matice</h3>

<pre>
matrixtest.core=&gt; <strong>(zero-matrix 2 3)</strong>
[[0.0 0.0 0.0] [0.0 0.0 0.0]]
&nbsp;
matrixtest.core=&gt; <strong>(pm *1)</strong>
[[0.000 0.000 0.000]
 [0.000 0.000 0.000]]
&nbsp;
matrixtest.core=&gt; <strong>(zero-matrix 4 4)</strong>
[[0.0 0.0 0.0 0.0] [0.0 0.0 0.0 0.0] [0.0 0.0 0.0 0.0] [0.0 0.0 0.0 0.0]]
&nbsp;
matrixtest.core=&gt; <strong>(pm *1)</strong>
[[0.000 0.000 0.000 0.000]
 [0.000 0.000 0.000 0.000]
 [0.000 0.000 0.000 0.000]
 [0.000 0.000 0.000 0.000]]
&nbsp;
matrixtest.core=&gt; <strong>(identity-matrix 4 4)</strong>
[[1.0 0.0 0.0 0.0] [0.0 1.0 0.0 0.0] [0.0 0.0 1.0 0.0] [0.0 0.0 0.0 1.0]]
&nbsp;
matrixtest.core=&gt; <strong>(pm *1)</strong>
[[1.000 0.000 0.000 0.000]
 [0.000 1.000 0.000 0.000]
 [0.000 0.000 1.000 0.000]
 [0.000 0.000 0.000 1.000]]
</pre>

<h3>Konstruktor permutační matice</h3>

<pre>
<i>; vektor udává pozice jedniček na jednotlivých řádcích matice</i>
<i>; rozměry matice jsou získány na základě velikosti tohoto vektoru</i>
matrixtest.core=&gt; <strong>(permutation-matrix [1 4 2 3 0])</strong>
#NDArray [[0.0 1.0 0.0 0.0 0.0] [0.0 0.0 0.0 0.0 1.0] [0.0 0.0 1.0 0.0 0.0] [0.0 0.0 0.0 1.0 0.0] [1.0 0.0 0.0 0.0 0.0]]
&nbsp;
matrixtest.core=&gt; <strong>(pm *1)</strong>
[[0.000 1.000 0.000 0.000 0.000]
 [0.000 0.000 0.000 0.000 1.000]
 [0.000 0.000 1.000 0.000 0.000]
 [0.000 0.000 0.000 1.000 0.000]
 [1.000 0.000 0.000 0.000 0.000]]
</pre>

<h3>Transpozice matice</h3>

<pre>
matrixtest.core=&gt; <strong>(def M (matrix [[1 2] [3 4]]))</strong>
#'matrixtest.core/M
&nbsp;
matrixtest.core=&gt; <strong>M</strong>
[[1 2] [3 4]]
&nbsp;
matrixtest.core=&gt; <strong>(pm *1)</strong>
[[1.000 2.000]
 [3.000 4.000]]
&nbsp;
matrixtest.core=&gt; <strong>(transpose M)</strong>
[[1 3] [2 4]]
&nbsp;
<i>; vypíše se hodnota transponované matice, původní matice M se nemění</i>
matrixtest.core=&gt; <strong>(pm *1)</strong>
[[1.000 3.000]
 [2.000 4.000]]
</pre>

<h3>Unární a binární operace nad maticemi</h3>

<pre>
matrixtest.core=&gt; <strong>(def M1 (matrix [[1 2][3 4]]))</strong>
#'matrixtest.core/M1
&nbsp;
matrixtest.core=&gt; <strong>(def M2 (matrix [[5 6][7 8]]))</strong>
#'matrixtest.core/M2
&nbsp;
matrixtest.core=&gt; <strong>(pm (+ M1 M2))</strong>
[[ 6.000  8.000]
 [10.000 12.000]]
&nbsp;
matrixtest.core=&gt; <strong>(pm (- M1 M2))</strong>
[[-4.000 -4.000]
 [-4.000 -4.000]]
&nbsp;
matrixtest.core=&gt; <strong>(pm (* M1 M2))</strong>
[[ 5.000 12.000]
 [21.000 32.000]]
&nbsp;
matrixtest.core=&gt; <strong>(pm (* M1 100))</strong>
[[100.000 200.000]
 [300.000 400.000]]
&nbsp;
<i>; zde se nejdříve vypočte inverzní matice k M1</i>
matrixtest.core=&gt; <strong>(pm (/ M2 M1))</strong>
[[5.000 3.000]
 [2.333 2.000]]
&nbsp;
matrixtest.core=&gt; <strong>(inverse M1)</strong>
#NDArrayDouble [[-1.9999999999999998 1.0] [1.4999999999999998 -0.49999999999999994]]
&nbsp;
matrixtest.core=&gt; <strong>(inverse M2)</strong>
#NDArrayDouble [[-4.000000000000002 3.0000000000000013] [3.5000000000000018 -2.5000000000000013]]
</pre>

<h3>Funkce vracející informaci o tom, zda je hodnota skalárem či maticí</h3>

<pre>
matrixtest.core=&gt; <strong>(def v (matrix [1 2 3 4 5 6]))</strong>
#'matrixtest.core/v
&nbsp;
matrixtest.core=&gt; <strong>(def M (matrix [[1 2] [3 4]]))</strong>
#'matrixtest.core/M
&nbsp;
<i>; jen 42 je skalární hodnota</i>
matrixtest.core=&gt; <strong>(for [obj [42 v M MD]] (array? obj))</strong>
(false true true true)
&nbsp;
<i>; jen 42 je skalární hodnota</i>
matrixtest.core=&gt; <strong>(for [obj [42 v M MD]] (scalar? obj))</strong>
(true false false false)
</pre>

<h3>Funkce vracející informace o maticích (počet dimenzí a tvar)</h3>

<pre>
matrixtest.core=&gt; <strong>(def v (matrix [1 2 3 4 5 6]))</strong>
#'matrixtest.core/v
&nbsp;
matrixtest.core=&gt; <strong>(def M (matrix [[1 2] [3 4]]))</strong>
#'matrixtest.core/M
&nbsp;
<i>; trojrozměrná matice</i>
matrixtest.core=&gt; <strong>(def MD (matrix [[ [1 2] [3 4] ] [ [5 6] [7 8] ] ]))</strong>
#'matrixtest.core/MD
&nbsp;
matrixtest.core=&gt; <strong>(pm MD)</strong>
[[[1.000 2.000]
  [3.000 4.000]]
 [[5.000 6.000]
  [7.000 8.000]]]
&nbsp;
matrixtest.core=&gt; <strong>(dimensionality v)</strong>
1
&nbsp;
matrixtest.core=&gt; <strong>(dimensionality M)</strong>
2
&nbsp;
matrixtest.core=&gt; <strong>(dimensionality MD)</strong>
3
&nbsp;
matrixtest.core=&gt; <strong>(dimensionality 1)</strong>
0
&nbsp;
matrixtest.core=&gt; <strong>(shape M)</strong>
[2 2]
&nbsp;
matrixtest.core=&gt; <strong>(shape v)</strong>
[6]
&nbsp;
matrixtest.core=&gt; <strong>(shape MD)</strong>
[2 2 2]
</pre>

<h3>Přečtení hodnoty prvku matice a získání řezu (slice)</h3>

<pre>
matrixtest.core=&gt; <strong>(mget M 0 0)</strong>
1
&nbsp;
matrixtest.core=&gt; <strong>(slice v 1)</strong>
2
&nbsp;
<i>; řez 2D maticí</i>
matrixtest.core=&gt; <strong>(slice M 1)</strong>
[3 4]
&nbsp;
<i>; řez 3D maticí</i>
matrixtest.core=&gt; <strong>(slice MD 1)</strong>
[[5 6] [7 8]]
&nbsp;
<i>; operace nad řezy</i>
matrixtest.core=&gt; <strong>(for [slice (slices M)] (apply + slice))</strong>
(3 7)
&nbsp;
<i>; vektorová! operace nad řezy</i>
matrixtest.core=&gt; <strong>(apply + (slices M))</strong>
[4 6]
</pre>

<h3>Změna tvaru matice</h3>

<pre>
matrixtest.core=&gt; <strong>(def v (matrix [1 2 3 4 5 6]))</strong>
#'matrixtest.core/v
&nbsp;
matrixtest.core=&gt; <strong>v</strong>
[1 2 3 4 5 6]
&nbsp;
<i>; velmi užitečná funkce převzatá z APL: vektor převeden na matici</i>
matrixtest.core=&gt; <strong>(reshape v [2 3])</strong>
[[1 2 3] [4 5 6]]
&nbsp;
matrixtest.core=&gt; <strong>(pm *1)</strong>
[[1.000 2.000 3.000]
 [4.000 5.000 6.000]]
&nbsp;
<i>; jiný tvar matice</i>
matrixtest.core=&gt; <strong>(reshape v [3 2])</strong>
[[1 2] [3 4] [5 6]]
&nbsp;
matrixtest.core=&gt; <strong>(pm *1)</strong>
[[1.000 2.000]
 [3.000 4.000]
 [5.000 6.000]]
&nbsp;
matrixtest.core=&gt; <strong>(reshape v [1 6])</strong>
[[1 2 3 4 5 6]]
&nbsp;
matrixtest.core=&gt; <strong>(pm *1)</strong>
[[1.000 2.000 3.000 4.000 5.000 6.000]]
&nbsp;
matrixtest.core=&gt; <strong>(reshape v [6 1])</strong>
[[1] [2] [3] [4] [5] [6]]
&nbsp;
<i>; sloupec z&nbsp;vektoru</i>
matrixtest.core=&gt; <strong>(pm *1)</strong>
[[1.000]
 [2.000]
 [3.000]
 [4.000]
 [5.000]
 [6.000]]
</pre>

<h3>Využití makra -&gt; ke kompozici operací</h3>

<pre>
<i>; jedná se o oneliner rozepsaný kvůli větší čitelnosti na čtyři řádky</i>
<strong>(-&gt; (matrix (range 1 101))
    (reshape [10 10])
    transpose
    pm)</strong>
[[ 1.000 11.000 21.000 31.000 41.000 51.000 61.000 71.000 81.000  91.000]
 [ 2.000 12.000 22.000 32.000 42.000 52.000 62.000 72.000 82.000  92.000]
 [ 3.000 13.000 23.000 33.000 43.000 53.000 63.000 73.000 83.000  93.000]
 [ 4.000 14.000 24.000 34.000 44.000 54.000 64.000 74.000 84.000  94.000]
 [ 5.000 15.000 25.000 35.000 45.000 55.000 65.000 75.000 85.000  95.000]
 [ 6.000 16.000 26.000 36.000 46.000 56.000 66.000 76.000 86.000  96.000]
 [ 7.000 17.000 27.000 37.000 47.000 57.000 67.000 77.000 87.000  97.000]
 [ 8.000 18.000 28.000 38.000 48.000 58.000 68.000 78.000 88.000  98.000]
 [ 9.000 19.000 29.000 39.000 49.000 59.000 69.000 79.000 89.000  99.000]
 [10.000 20.000 30.000 40.000 50.000 60.000 70.000 80.000 90.000 100.000]]
&nbsp;
<i>; sekvence operací aplikovaných na matici M1</i>
<strong>(-&gt; M1
    transpose
    inverse
    (* 10000)
    transpose
    (* M2)
    (+ M1)
    pm)</strong>
[[-99999.000  60002.000]
 [105003.000 -39996.000]]
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Obsah následující části seriálu</h2>

<p>V&nbsp;navazující části seriálu o světě lispovských jazyků si představíme
pravděpodobně nejrozsáhlejší a nejúplnější implementaci programovacího jazyka
Scheme. Jedná se o jazyk <i>Racket</i>, který je dodáván i s&nbsp;interaktivním
vývojovým prostředím a množstvím přídavných modulů pokrývajících různá odvětví
informatiky (včetně počítačové grafiky, numerických výpočtů atd.).</p>

<img src="https://i.iinfo.cz/images/15/racket-logo-1.png" class="image-367448" alt="&#160;" width="350" height="350" />
<p><i>Obrázek 1: Logo projektu Racket.</i></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů naprogramovaných
v&nbsp;jazyce Kawa byly uloženy do Git repositáře, který je dostupný na adrese
<a
href="https://github.com/tisnik/lisp-families.git">https://github.com/tisnik/lisp-families.git</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, můžete
namísto toho použít odkazy na jednotlivé příklady, které naleznete
v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>Array1.scm</td><td>vytvoření jednorozměrného pole s&nbsp;prvky typu <strong>int</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/Array1.scm">https://github.com/tisnik/lisp-families/blob/master/kawa/Array1.scm</a></td></tr>
<tr><td> 2</td><td>Array1.asm</td><td>disassemblovaný soubor .class předchozího skriptu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/Array1.asm">https://github.com/tisnik/lisp-families/blob/master/kawa/Array1.asm</a></td></tr>
<tr><td> 3</td><td>Array2_exception.scm</td><td>výjimka při přístupu k&nbsp;neexistujícímu prvku</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/Array2_exception.scm">https://github.com/tisnik/lisp-families/blob/master/kawa/Array2_exception.scm</a></td></tr>
<tr><td> 4</td><td>Array2.scm</td><td>vytvoření pole a přístup k&nbsp;jeho prvkům</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/Array2.scm">https://github.com/tisnik/lisp-families/blob/master/kawa/Array2.scm</a></td></tr>
<tr><td> 5</td><td>Array2.asm</td><td>disassemblovaný soubor .class předchozího skriptu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/Array2.asm">https://github.com/tisnik/lisp-families/blob/master/kawa/Array2.asm</a></td></tr>
<tr><td> 6</td><td>Array3.scm</td><td>pole s&nbsp;odlišnými hodnotami</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/Array3.scm">https://github.com/tisnik/lisp-families/blob/master/kawa/Array3.scm</a></td></tr>
<tr><td> 7</td><td>Array3.asm</td><td>disassemblovaný soubor .class předchozího skriptu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/Array3.asm">https://github.com/tisnik/lisp-families/blob/master/kawa/Array3.asm</a></td></tr>
<tr><td> 8</td><td>Array4.scm</td><td>pole s&nbsp;prvky typu <strong>float</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/Array4.scm">https://github.com/tisnik/lisp-families/blob/master/kawa/Array4.scm</a></td></tr>
<tr><td> 9</td><td>Array4.asm</td><td>disassemblovaný soubor .class předchozího skriptu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/Array4.asm">https://github.com/tisnik/lisp-families/blob/master/kawa/Array4.asm</a></td></tr>
<tr><td>10</td><td>CreateArray1.scm</td><td>funkce pro vytvoření pole zadané délky</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/CreateArray1.scm">https://github.com/tisnik/lisp-families/blob/master/kawa/CreateArray1.scm</a></td></tr>
<tr><td>11</td><td>CreateArray1.asm</td><td>disassemblovaný soubor .class předchozího skriptu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/CreateArray1.asm">https://github.com/tisnik/lisp-families/blob/master/kawa/CreateArray1.asm</a></td></tr>
<tr><td>12</td><td>CreateArray2.scm</td><td>vylepšení funkce pro vytvoření pole zadané délky</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/CreateArray2.scm">https://github.com/tisnik/lisp-families/blob/master/kawa/CreateArray2.scm</a></td></tr>
<tr><td>13</td><td>CreateArray2.asm</td><td>disassemblovaný soubor .class předchozího skriptu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/CreateArray2.asm">https://github.com/tisnik/lisp-families/blob/master/kawa/CreateArray2.asm</a></td></tr>
<tr><td>14</td><td>CreateArray3.scm</td><td>vytvoření pole řetězců</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/CreateArray3.scm">https://github.com/tisnik/lisp-families/blob/master/kawa/CreateArray3.scm</a></td></tr>
<tr><td>15</td><td>CreateArray3.asm</td><td>disassemblovaný soubor .class předchozího skriptu</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/CreateArray3.asm">https://github.com/tisnik/lisp-families/blob/master/kawa/CreateArray3.asm</a></td></tr>
<tr><td>16</td><td>Matrix1.scm</td><td>matice 3&times;3 prvky</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/Matrix1.scm">https://github.com/tisnik/lisp-families/blob/master/kawa/Matrix1.scm</a></td></tr>
<tr><td>17</td><td>Matrix2.scm</td><td>nepravidelná matice s&nbsp;prvky typu <strong>int</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/Matrix2.scm">https://github.com/tisnik/lisp-families/blob/master/kawa/Matrix2.scm</a></td></tr>
<tr><td>18</td><td>Matrix3.scm</td><td>nepravidelná matice s&nbsp;prvky typu <strong>float</strong></td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/Matrix3.scm">https://github.com/tisnik/lisp-families/blob/master/kawa/Matrix3.scm</a></td></tr>
<tr><td>19</td><td>ranges1.scm</td><td>příklad použití rozsahů</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/ranges1.scm">https://github.com/tisnik/lisp-families/blob/master/kawa/ranges1.scm</a></td></tr>
<tr><td>20</td><td>ranges2.scm</td><td>výběr prvků s&nbsp;využitím rozsahů</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/ranges2.scm">https://github.com/tisnik/lisp-families/blob/master/kawa/ranges2.scm</a></td></tr>
<tr><td>21</td><td>Vectors1.scm</td><td>jednorozměrné vektory</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/Vectors1.scm">https://github.com/tisnik/lisp-families/blob/master/kawa/Vectors1.scm</a></td></tr>
<tr><td>22</td><td>Vectors2.scm</td><td>přístup k&nbsp;prvkům vektorů a modifikace jejich hodnot</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/Vectors2.scm">https://github.com/tisnik/lisp-families/blob/master/kawa/Vectors2.scm</a></td></tr>
<tr><td>23</td><td>Makefile</td><td>soubor <strong>Makefile</strong> určený pro překlad demonstračních skriptů do bajtkódu a pro jejich disassembling</td><td><a href="https://github.com/tisnik/lisp-families/blob/master/kawa/Makefile">https://github.com/tisnik/lisp-families/blob/master/kawa/Makefile</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Literatura</h2>

<ol>

<li>Peter Seibel<br />
<i>&bdquo;Practical Common Lisp&ldquo;</i><br />
2009
</li>

<li>Paul Graham<br />
<i>&bdquo;ANSI Common Lisp&ldquo;</i><br />
1995
</li>

<li>Gerald Gazdar<br />
<i>&bdquo;Natural Language Processing in Lisp: An Introduction to Computational Linguistics&ldquo;</i><br />
1989
</li>

<li>Peter Norvig<br />
<i>&bdquo;Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp&ldquo;</i><br />
1991
</li>

<li>Alex Mileler et.al.<br />
<i>&bdquo;Clojure Applied: From Practice to Practitioner&ldquo;</i><br />
2015
</li>

<li>
<i>&bdquo;Living Clojure: An Introduction and Training Plan for Developers&ldquo;</i><br />
2015
</li>

<li>Dmitri Sotnikov<br />
<i>&bdquo;Web Development with Clojure: Build Bulletproof Web Apps with Less Code&ldquo;</i><br />
2016
</li>

<li>McCarthy<br />
<i>&bdquo;Recursive functions of symbolic expressions and their computation by machine, part I&ldquo;</i><br />
1960
</li>

<li>R. Kent Dybvig<br />
<i>&bdquo;The Scheme Programming Language&ldquo;</i><br />
2009
</li>

<li>Max Hailperin<br />
<i>&bdquo;Concrete Abstractions&ldquo;</i><br />
1998
</li>

<li>Guy L. Steele<br />
<i>&bdquo;History of Scheme&ldquo;</i><br />
2006, Sun Microsystems Laboratories
</li>

<li>Kolář J., Muller K.:<br />
<i>&bdquo;Speciální programovací jazyky&ldquo;</i><br />
Praha 1981
</li>

<li>
<i>&bdquo;AutoLISP Release 9, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., October 1987
</li>

<li>
<i>&bdquo;AutoLISP Release 10, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., September 1988
</li>

<li>McCarthy, John; Abrahams, Paul W.; Edwards, Daniel J.; Hart, Timothy P.; Levin, Michael I.<br />
<i>&bdquo;LISP 1.5 Programmer's Manual&ldquo;</i><br />
MIT Press. ISBN 0 262 130 1 1 4
</li>

<li>Carl Hewitt; Peter Bishop and Richard Steiger<br />
<i>&bdquo;A Universal Modular Actor Formalism for Artificial Intelligence&ldquo;</i><br />
1973
</li>

<li>Feiman, J.<br />
<i>&bdquo;The Gartner Programming Language Survey (October 2001)&ldquo;</i><br />
Gartner Advisory
</li>

<li>Harold Abelson, Gerald Jay Sussman, Julie Sussman:<br />
<i>Structure and Interpretation of Computer Programs</i><br />
MIT Press. 1985, 1996 (a možná vyšel i další přetisk)
</li>

<li>Paul Graham<br />
<i>On Lisp</i><br />
Prentice Hall, 1993<br />
Dostupné online na stránce <a href="http://www.paulgraham.com/onlisptext.html">http://www.paulgraham.com/onlisptext.html</a>
</li>

<li>David S. Touretzky<br />
<i>Common LISP: A Gentle Introduction to Symbolic Computation (Dover Books on Engineering)</i><br />
</li>

<li>Peter Norvig<br />
<i>Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp</i>
</li>

<li>Patrick Winston, Berthold Horn<br />
<i>Lisp (3rd Edition)</i><br />
ISBN-13: 978-0201083194, ISBN-10: 0201083191
</li>

<li>Matthias Felleisen, David Van Horn, Dr. Conrad Barski<br>
<i>Realm of Racket: Learn to Program, One Game at a Time!</i><br />
ISBN-13: 978-1593274917, ISBN-10: 1593274912 
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Vector Library (R7RS-compatible)<br />
<a href="https://srfi.schemers.org/srfi-133/srfi-133.html">https://srfi.schemers.org/srfi-133/srfi-133.html</a>
</li>

<li>Vectors (pro Gauche)<br />
<a href="https://practical-scheme.net/gauche/man/gauche-refe/Vectors.html">https://practical-scheme.net/gauche/man/gauche-refe/Vectors.html</a>
</li>

<li>Kawa: Compiling Scheme to Java<br />
<a href="https://www.mit.edu/afs.new/sipb/project/kawa/doc/kawa-tour.html">https://www.mit.edu/afs.new/sipb/project/kawa/doc/kawa-tour.html</a>
</li>

<li>Kawa in Languages shootout<br />
<a href="http://per.bothner.com/blog/2010/Kawa-in-shootout/">http://per.bothner.com/blog/2010/Kawa-in-shootout/</a>
</li>

<li>Kawa 2.0 Supports Scheme R7RS<br />
<a href="https://developers.slashdot.org/story/14/12/13/2259225/kawa-20-supports-scheme-r7rs/">https://developers.slashdot.org/story/14/12/13/2259225/kawa-20-supports-scheme-r7rs/</a>
</li>

<li>Kawa — fast scripting on the Java platform<br />
<a href="https://lwn.net/Articles/623349/">https://lwn.net/Articles/623349/</a>
</li>

<li>Tail call (a její optimalizace)<br />
<a href="https://en.wikipedia.org/wiki/Tail_call">https://en.wikipedia.org/wiki/Tail_call</a>
</li>

<li>SLIME (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/SLIME">http://en.wikipedia.org/wiki/SLIME</a>
</li>

<li>slime.vim<br />
<a href="http://s3.amazonaws.com/mps/slime.vim">http://s3.amazonaws.com/mps/slime.vim</a>
</li>

<li>What are the best scheme implementations?<br />
<a href="https://www.slant.co/topics/5282/~scheme-implementations">https://www.slant.co/topics/5282/~scheme-implementations</a>
</li>

<li>Bigloo homepage<br />
<a href="http://www-sop.inria.fr/mimosa/fp/Bigloo/">http://www-sop.inria.fr/mimosa/fp/Bigloo/</a>
</li>

<li>FTP s tarbally Bigloo<br />
<a href="ftp://ftp-sop.inria.fr/indes/fp/Bigloo">ftp://ftp-sop.inria.fr/indes/fp/Bigloo</a>
</li>

<li>GOTO 2018 • Functional Programming in 40 Minutes • Russ Olsen<br />
<a href="https://www.youtube.com/watch?v=0if71HOyVjY">https://www.youtube.com/watch?v=0if71HOyVjY</a>
</li>

<li>TinyScheme (stránka na Sourceforge)<br />
<a href="http://tinyscheme.sourceforge.net/home.html">http://tinyscheme.sourceforge.net/home.html</a>
</li>

<li>Embedding Tiny Scheme in a Game<br />
<a href="http://www.silicondelight.com/embedding-tiny-scheme-in-a-game/">http://www.silicondelight.com/embedding-tiny-scheme-in-a-game/</a>
</li>

<li>Embedding Scheme for a game mission scripting DSL<br />
<a href="http://carloscarrasco.com/embedding-scheme-for-a-game-mission-scripting-dsl.html">http://carloscarrasco.com/embedding-scheme-for-a-game-mission-scripting-dsl.html</a>
</li>

<li>Všechny verze TinyScheme na SourceForge<br />
<a href="https://sourceforge.net/projects/tinyscheme/files/tinyscheme/">https://sourceforge.net/projects/tinyscheme/files/tinyscheme/</a>
</li>

<li>Fork TinyScheme na GitHubu<br />
<a href="https://github.com/yawnt/tinyscheme">https://github.com/yawnt/tinyscheme</a>
</li>

<li>Ackermannova funkce<br />
<a href="https://cs.wikipedia.org/wiki/Ackermannova_funkce">https://cs.wikipedia.org/wiki/Ackermannova_funkce</a>
</li>

<li>Ackermann function na Rosetta Code<br />
<a href="https://rosettacode.org/wiki/Ackermann_function#Scheme">https://rosettacode.org/wiki/Ackermann_function#Scheme</a>
</li>

<li>Success Stories (lisp.org)<br />
<a href="https://lisp-lang.org/success/">https://lisp-lang.org/success/</a>
</li>

<li>Allegro Common Lisp Success Stories<br />
<a href="https://franz.com/success/">https://franz.com/success/</a>
</li>

<li>Clojure Success Stories<br />
<a href="https://clojure.org/community/success_stories">https://clojure.org/community/success_stories</a>
</li>

<li>Scheme Quick Reference<br />
<a href="https://www.st.cs.uni-saarland.de/edu/config-ss04/scheme-quickref.pdf">https://www.st.cs.uni-saarland.de/edu/config-ss04/scheme-quickref.pdf</a>
</li>

<li>Slajdy o Scheme (od slajdu číslo 15)<br />
<a href="https://docs.google.com/presentation/d/1abmDnKjrq1tcjGvvRNAKhOiSTSE2lyagtcEPal07Gbo/edit">https://docs.google.com/presentation/d/1abmDnKjrq1tcjGvvRNAKhOiSTSE2lyagtcEPal07Gbo/edit</a>
</li>

<li>Scheme Cheat Sheet<br />
<a href="https://github.com/smythp/scheme-cheat-sheet">https://github.com/smythp/scheme-cheat-sheet</a>
</li>

<li>Embedding Lua, embedding Guile <br />
<a href="http://puntoblogspot.blogspot.com/2013/04/embedding-lua-embedding-guile.html">http://puntoblogspot.blogspot.com/2013/04/embedding-lua-embedding-guile.html</a>
</li>

<li>Lambda Papers<br />
<a href="https://en.wikisource.org/wiki/Lambda_Papers">https://en.wikisource.org/wiki/Lambda_Papers</a>
</li>

<li>Revised<sup>7</sup>Report on the Algorithmic Language Scheme<br />
<a href="https://small.r7rs.org/attachment/r7rs.pdf">https://small.r7rs.org/attachment/r7rs.pdf</a>
</li>

<li>Video Lectures (MIT, SICP 2005)<br />
<a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/">https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/</a>
</li>

<li>Why is Scheme my first language in university?<br />
<a href="https://softwareengineering.stackexchange.com/questions/115252/why-is-scheme-my-first-language-in-university">https://softwareengineering.stackexchange.com/questions/115252/why-is-scheme-my-first-language-in-university</a>
</li>

<li>The Perils of JavaSchools<br />
<a href="https://www.joelonsoftware.com/2005/12/29/the-perils-of-javaschools-2/">https://www.joelonsoftware.com/2005/12/29/the-perils-of-javaschools-2/</a>
</li>

<li>How to Design Programs, Second Edition<br />
<a href="https://htdp.org/2019-02-24/index.html">https://htdp.org/2019-02-24/index.html</a>
</li>

<li>LilyPond<br />
<a href="http://lilypond.org/">http://lilypond.org/</a>
</li>

<li>LilyPond — Extending (přes Scheme)<br />
<a href="http://lilypond.org/doc/v2.18/Documentation/extending/scheme-tutorial">http://lilypond.org/doc/v2.18/Documentation/extending/scheme-tutorial</a>
</li>

<li>Scheme in LilyPond<br />
<a href="http://lilypond.org/doc/v2.18/Documentation/extending/scheme-in-lilypond">http://lilypond.org/doc/v2.18/Documentation/extending/scheme-in-lilypond</a>
</li>

<li>GnuCash<br />
<a href="http://www.gnucash.org/">http://www.gnucash.org/</a>
</li>

<li>Custom Reports (in GNU Cash)<br />
<a href="https://wiki.gnucash.org/wiki/Custom_Reports">https://wiki.gnucash.org/wiki/Custom_Reports</a>
</li>

<li>Program by Design<br />
<a href="https://programbydesign.org/">https://programbydesign.org/</a>
</li>

<li>SchemePy<br />
<a href="https://pypi.org/project/SchemePy/">https://pypi.org/project/SchemePy/</a>
</li>

<li>LISP FQA: Section - [1-5] What is the "minimal" set of primitives needed for a Lisp interpreter?<br />
<a href="http://www.faqs.org/faqs/lisp-faq/part1/section-6.html">http://www.faqs.org/faqs/lisp-faq/part1/section-6.html</a>
</li>

<li>femtolisp<br />
<a href="https://github.com/JeffBezanson/femtolisp">https://github.com/JeffBezanson/femtolisp</a>
</li>

<li>(How to Write a (Lisp) Interpreter (in Python))<br />
<a href="http://norvig.com/lispy.html">http://norvig.com/lispy.html</a>
</li>

<li>Repositář s&nbsp;Guile Emacsem<br />
<a href="http://git.hcoop.net/?p=bpt/guile.git">http://git.hcoop.net/?p=bpt/guile.git</a>
</li>

<li>Interacting with Guile Compound Data Types in C<br />
<a href="http://www.lonelycactus.com/guilebook/x1555.html">http://www.lonelycactus.com/guilebook/x1555.html</a>
</li>

<li>Calling Guile functions from C<br />
<a href="http://www.lonelycactus.com/guilebook/c1204.html#SECCALLGUILEFUNC">http://www.lonelycactus.com/guilebook/c1204.html#SECCALLGUILEFUNC</a>
</li>

<li>Arrays, and other compound data types<br />
<a href="http://www.lonelycactus.com/guilebook/charrays.html">http://www.lonelycactus.com/guilebook/charrays.html</a>
</li>

<li>Interacting with Guile Compound Data Types in C<br />
<a href="http://www.lonelycactus.com/guilebook/x1555.html">http://www.lonelycactus.com/guilebook/x1555.html</a>
</li>

<li>Guile Reference Manual<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/index.html">https://www.gnu.org/software/guile/manual/html_node/index.html</a>
</li>

<li>Scheme: Summary of Common Syntax<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/Syntax-Summary.html#Syntax-Summary">https://www.gnu.org/software/guile/manual/html_node/Syntax-Summary.html#Syntax-Summary</a>
</li>

<li>Scripting with Guile: Extension language enhances C and Scheme<br />
<a href="https://www.ibm.com/developerworks/library/l-guile/index.html">https://www.ibm.com/developerworks/library/l-guile/index.html</a>
</li>

<li>Having fun with Guile: a tutorial<br />
<a href="http://dustycloud.org/misc/guile-tutorial.html">http://dustycloud.org/misc/guile-tutorial.html</a>
</li>

<li>Guile: Loading Readline Support<br />
<a href="https://www.gnu.org/software/guile/manual/html_node/Loading-Readline-Support.html#Loading-Readline-Support">https://www.gnu.org/software/guile/manual/html_node/Loading-Readline-Support.html#Loading-Readline-Support</a>
</li>

<li>lispy<br />
<a href="https://pypi.org/project/lispy/">https://pypi.org/project/lispy/</a>
</li>

<li>Lython<br />
<a href="https://pypi.org/project/Lython/">https://pypi.org/project/Lython/</a>
</li>

<li>Lizpop<br />
<a href="https://pypi.org/project/lizpop/">https://pypi.org/project/lizpop/</a>
</li>

<li>Budoucnost programovacích jazyků<br />
<a href="http://www.knesl.com/budoucnost-programovacich-jazyku">http://www.knesl.com/budoucnost-programovacich-jazyku</a>
</li>

<li>LISP Prolog and Evolution<br />
<a href="http://blog.samibadawi.com/2013/05/lisp-prolog-and-evolution.html">http://blog.samibadawi.com/2013/05/lisp-prolog-and-evolution.html</a>
</li>

<li>List of Lisp-family programming languages<br />
<a href="https://en.wikipedia.org/wiki/List_of_Lisp-family_programming_languages">https://en.wikipedia.org/wiki/List_of_Lisp-family_programming_languages</a>
</li>

<li>clojure_py na indexu PyPi<br />
<a href="https://pypi.python.org/pypi/clojure_py">https://pypi.python.org/pypi/clojure_py</a>
</li>

<li>PyClojure<br />
<a href="https://github.com/eigenhombre/PyClojure">https://github.com/eigenhombre/PyClojure</a>
</li>

<li>Hy na GitHubu<br />
<a href="https://github.com/hylang/hy">https://github.com/hylang/hy</a>
</li>

<li>Hy: The survival guide<br />
<a href="https://notes.pault.ag/hy-survival-guide/">https://notes.pault.ag/hy-survival-guide/</a>
</li>

<li>Hy běžící na monitoru terminálu společnosti Symbolics<br />
<a href="http://try-hy.appspot.com/">http://try-hy.appspot.com/</a>
</li>

<li>Welcome to Hy’s documentation!<br />
<a href="http://docs.hylang.org/en/stable/">http://docs.hylang.org/en/stable/</a>
</li>

<li>Hy na PyPi<br />
<a href="https://pypi.org/project/hy/#description">https://pypi.org/project/hy/#description</a>
</li>

<li>Getting Hy on Python<br />
<a href="https://lwn.net/Articles/596626/">https://lwn.net/Articles/596626/</a>
</li>

<li>Programming Can Be Fun with Hy<br />
<a href="https://opensourceforu.com/2014/02/programming-can-fun-hy/">https://opensourceforu.com/2014/02/programming-can-fun-hy/</a>
</li>

<li>Přednáška o projektu Hy (pětiminutový lighttalk)<br />
<a href="http://blog.pault.ag/day/2013/04/02">http://blog.pault.ag/day/2013/04/02</a>
</li>

<li>Hy (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Hy">https://en.wikipedia.org/wiki/Hy</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Point<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Point.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Point.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Narrowing<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Narrowing.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Narrowing.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Functions that Create Markers<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Markers.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Markers.html</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Motion<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Motion.html#Motion">https://www.gnu.org/software/emacs/manual/html_node/elisp/Motion.html#Motion</a>
</li>

<li>GNU Emacs Lisp Reference Manual: Basic Char Syntax<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Basic-Char-Syntax.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/Basic-Char-Syntax.html</a>
</li>

<li>Elisp: Sequence: List, Array<br />
<a href="http://ergoemacs.org/emacs/elisp_list_vs_vector.html">http://ergoemacs.org/emacs/elisp_list_vs_vector.html</a>
</li>

<li>Elisp: Property List<br />
<a href="http://ergoemacs.org/emacs/elisp_property_list.html">http://ergoemacs.org/emacs/elisp_property_list.html</a>
</li>

<li>Elisp: Hash Table<br />
<a href="http://ergoemacs.org/emacs/elisp_hash_table.html">http://ergoemacs.org/emacs/elisp_hash_table.html</a>
</li>

<li>Elisp: Association List<br />
<a href="http://ergoemacs.org/emacs/elisp_association_list.html">http://ergoemacs.org/emacs/elisp_association_list.html</a>
</li>

<li>The mapcar Function (An Introduction to Programming in Emacs Lisp)<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/mapcar.html">https://www.gnu.org/software/emacs/manual/html_node/eintr/mapcar.html</a>
</li>

<li>Anaphoric macro<br />
<a href="https://en.wikipedia.org/wiki/Anaphoric_macro">https://en.wikipedia.org/wiki/Anaphoric_macro</a>
</li>

<li>Some Common Lisp Loop Macro Examples<br />
<a href="https://www.youtube.com/watch?v=3yl8o6r_omw">https://www.youtube.com/watch?v=3yl8o6r_omw</a>
</li>

<li>A Guided Tour of Emacs<br />
<a href="https://www.gnu.org/software/emacs/tour/">https://www.gnu.org/software/emacs/tour/</a>
</li>

<li>The Roots of Lisp<br />
<a href="http://www.paulgraham.com/rootsoflisp.html">http://www.paulgraham.com/rootsoflisp.html</a>
</li>

<li>Evil (Emacs Wiki)<br />
<a href="https://www.emacswiki.org/emacs/Evil">https://www.emacswiki.org/emacs/Evil</a>
</li>

<li>Evil (na GitHubu)<br />
<a href="https://github.com/emacs-evil/evil">https://github.com/emacs-evil/evil</a>
</li>

<li>Evil (na stránkách repositáře MELPA)<br />
<a href="https://melpa.org/#/evil">https://melpa.org/#/evil</a>
</li>

<li>Evil Mode: How I Switched From VIM to Emacs<br />
<a href="https://blog.jakuba.net/2014/06/23/evil-mode-how-to-switch-from-vim-to-emacs.html">https://blog.jakuba.net/2014/06/23/evil-mode-how-to-switch-from-vim-to-emacs.html</a>
</li>

<li>GNU Emacs (home page)<br />
<a href="https://www.gnu.org/software/emacs/">https://www.gnu.org/software/emacs/</a>
</li>

<li>GNU Emacs (texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?GnuEmacs">http://texteditors.org/cgi-bin/wiki.pl?GnuEmacs</a>
</li>

<li>An Introduction To Using GDB Under Emacs<br />
<a href="http://tedlab.mit.edu/~dr/gdbintro.html">http://tedlab.mit.edu/~dr/gdbintro.html</a>
</li>

<li>An Introduction to Programming in Emacs Lisp<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html">https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html</a>
</li>

<li>27.6 Running Debuggers Under Emacs<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html">https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html</a>
</li>

<li>GdbMode<br />
<a href="http://www.emacswiki.org/emacs/GdbMode">http://www.emacswiki.org/emacs/GdbMode</a>
</li>

<li>Emacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Emacs">https://en.wikipedia.org/wiki/Emacs</a>
</li>

<li>Emacs timeline<br />
<a href="http://www.jwz.org/doc/emacs-timeline.html">http://www.jwz.org/doc/emacs-timeline.html</a>
</li>

<li>Emacs Text Editors Family<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?EmacsFamily">http://texteditors.org/cgi-bin/wiki.pl?EmacsFamily</a>
</li>

<li>Vrapper aneb spojení možností Vimu a Eclipse<br />
<a href="https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse/">https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse/</a>
</li>

<li>Vrapper aneb spojení možností Vimu a Eclipse (část 2: vyhledávání a nahrazování textu)<br />
<a href="https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse-cast-2-vyhledavani-a-nahrazovani-textu/">https://mojefedora.cz/vrapper-aneb-spojeni-moznosti-vimu-a-eclipse-cast-2-vyhledavani-a-nahrazovani-textu/</a>
</li>

<li>Emacs/Evil-mode - A basic reference to using evil mode in Emacs<br />
<a href="http://www.aakarshnair.com/posts/emacs-evil-mode-cheatsheet">http://www.aakarshnair.com/posts/emacs-evil-mode-cheatsheet</a>
</li>

<li>From Vim to Emacs+Evil chaotic migration guide<br />
<a href="https://juanjoalvarez.net/es/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/">https://juanjoalvarez.net/es/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/</a>
</li>

<li>Introduction to evil-mode {video)<br />
<a href="https://www.youtube.com/watch?v=PeVQwYUxYEg">https://www.youtube.com/watch?v=PeVQwYUxYEg</a>
</li>

<li>EINE (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/EINE">http://www.emacswiki.org/emacs/EINE</a>
</li>

<li>EINE (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?EINE">http://texteditors.org/cgi-bin/wiki.pl?EINE</a>
</li>

<li>ZWEI (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/ZWEI">http://www.emacswiki.org/emacs/ZWEI</a>
</li>

<li>ZWEI (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?ZWEI">http://texteditors.org/cgi-bin/wiki.pl?ZWEI</a>
</li>

<li>Zmacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Zmacs">https://en.wikipedia.org/wiki/Zmacs</a>
</li>

<li>Zmacs (Texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?Zmacs">http://texteditors.org/cgi-bin/wiki.pl?Zmacs</a>
</li>

<li>TecoEmacs (Emacs Wiki)<br />
<a href="http://www.emacswiki.org/emacs/TecoEmacs">http://www.emacswiki.org/emacs/TecoEmacs</a>
</li>

<li>Micro Emacs<br />
<a href="http://www.emacswiki.org/emacs/MicroEmacs">http://www.emacswiki.org/emacs/MicroEmacs</a>
</li>

<li>Micro Emacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/MicroEMACS">https://en.wikipedia.org/wiki/MicroEMACS</a>
</li>

<li>EmacsHistory<br />
<a href="http://www.emacswiki.org/emacs/EmacsHistory">http://www.emacswiki.org/emacs/EmacsHistory</a>
</li>

<li>Seznam editorů s ovládáním podobným Emacsu či kompatibilních s příkazy Emacsu<br />
<a href="http://www.finseth.com/emacs.html">http://www.finseth.com/emacs.html</a>
</li>

<li>evil-numbers<br />
<a href="https://github.com/cofi/evil-numbers">https://github.com/cofi/evil-numbers</a>
</li>

<li>Debuggery a jejich nadstavby v&nbsp;Linuxu (1.část)<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/</a>
</li>

<li>Debuggery a jejich nadstavby v&nbsp;Linuxu (2.část)<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (3): Nemiver<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (4): KDbg<br />
<a href="http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/">http://fedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (5): ladění aplikací v editorech Emacs a Vim<br />
<a href="https://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/">https://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/</a>
</li>

<li>Org mode<br />
<a href="https://orgmode.org/">https://orgmode.org/</a>
</li>

<li>The Org Manual<br />
<a href="https://orgmode.org/manual/index.html">https://orgmode.org/manual/index.html</a>
</li>

<li>Kakoune (modální textový editor)<br />
<a href="http://kakoune.org/">http://kakoune.org/</a>
</li>

<li>Vim-style keybinding in Emacs/Evil-mode<br />
<a href="https://gist.github.com/troyp/6b4c9e1c8670200c04c16036805773d8">https://gist.github.com/troyp/6b4c9e1c8670200c04c16036805773d8</a>
</li>

<li>Emacs - jak začít<br />
<a href="http://www.abclinuxu.cz/clanky/navody/emacs-jak-zacit">http://www.abclinuxu.cz/clanky/navody/emacs-jak-zacit</a>
</li>

<li>Programovací jazyk LISP a LISP machines<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-lisp-a-lisp-machines/">https://www.root.cz/clanky/programovaci-jazyk-lisp-a-lisp-machines/</a>
</li>

<li>Evil-surround<br />
<a href="https://github.com/emacs-evil/evil-surround">https://github.com/emacs-evil/evil-surround</a>
</li>

<li>Spacemacs<br />
<a href="http://spacemacs.org/">http://spacemacs.org/</a>
</li>

<li>Lisp: Common Lisp, Racket, Clojure, Emacs Lisp<br />
<a href="http://hyperpolyglot.org/lisp">http://hyperpolyglot.org/lisp</a>
</li>

<li>Common Lisp, Scheme, Clojure, And Elisp Compared<br />
<a href="http://irreal.org/blog/?p=725">http://irreal.org/blog/?p=725</a>
</li>

<li>Does Elisp Suck?<br />
<a href="http://irreal.org/blog/?p=675">http://irreal.org/blog/?p=675</a>
</li>

<li>Emacs pro mírně pokročilé (9): Elisp<br />
<a href="https://www.root.cz/clanky/emacs-elisp/">https://www.root.cz/clanky/emacs-elisp/</a>
</li>

<li>If I want to learn lisp, are emacs and elisp a good choice?<br />
<a href="https://www.reddit.com/r/emacs/comments/2m141y/if_i_want_to_learn_lisp_are_emacs_and_elisp_a/">https://www.reddit.com/r/emacs/comments/2m141y/if_i_want_to_learn_lisp_are_emacs_and_elisp_a/</a>
</li>

<li>Clojure(Script) Interactive Development Environment that Rocks!<br />
<a href="https://github.com/clojure-emacs/cider">https://github.com/clojure-emacs/cider</a>
</li>

<li>An Introduction to Emacs Lisp<br />
<a href="https://harryrschwartz.com/2014/04/08/an-introduction-to-emacs-lisp.html">https://harryrschwartz.com/2014/04/08/an-introduction-to-emacs-lisp.html</a>
</li>

<li>Emergency Elisp<br />
<a href="http://steve-yegge.blogspot.com/2008/01/emergency-elisp.html">http://steve-yegge.blogspot.com/2008/01/emergency-elisp.html</a>
</li>

<li>Lambda calculus<br />
<a href="https://en.wikipedia.org/wiki/Lambda_calculus">https://en.wikipedia.org/wiki/Lambda_calculus</a>
</li>

<li>John McCarthy's original LISP paper from 1959<br />
<a href="https://www.reddit.com/r/programming/comments/17lpz4/john_mccarthys_original_lisp_paper_from_1959/">https://www.reddit.com/r/programming/comments/17lpz4/john_mccarthys_original_lisp_paper_from_1959/</a>
</li>

<li>Micro Manual LISP<br />
<a href="https://www.scribd.com/document/54050141/Micro-Manual-LISP">https://www.scribd.com/document/54050141/Micro-Manual-LISP</a>
</li>

<li>How Lisp Became God's Own Programming Language<br />
<a href="https://twobithistory.org/2018/10/14/lisp.html">https://twobithistory.org/2018/10/14/lisp.html</a>
</li>

<li>History of Lisp<br />
<a href="http://jmc.stanford.edu/articles/lisp/lisp.pdf">http://jmc.stanford.edu/articles/lisp/lisp.pdf</a>
</li>

<li>The Roots of Lisp<br />
<a href="http://languagelog.ldc.upenn.edu/myl/llog/jmc.pdf">http://languagelog.ldc.upenn.edu/myl/llog/jmc.pdf</a>
</li>

<li>Racket<br />
<a href="https://racket-lang.org/">https://racket-lang.org/</a>
</li>

<li>The Racket Manifesto<br />
<a href="http://felleisen.org/matthias/manifesto/">http://felleisen.org/matthias/manifesto/</a>
</li>

<li>MIT replaces Scheme with Python<br />
<a href="https://www.johndcook.com/blog/2009/03/26/mit-replaces-scheme-with-python/">https://www.johndcook.com/blog/2009/03/26/mit-replaces-scheme-with-python/</a>
</li>

<li>Adventures in Advanced Symbolic Programming<br />
<a href="http://groups.csail.mit.edu/mac/users/gjs/6.945/">http://groups.csail.mit.edu/mac/users/gjs/6.945/</a>
</li>

<li>Why MIT Switched from Scheme to Python (2009)<br />
<a href="https://news.ycombinator.com/item?id=14167453">https://news.ycombinator.com/item?id=14167453</a>
</li>

<li>Starodávná stránka XLispu<br />
<a href="http://www.xlisp.org/">http://www.xlisp.org/</a>
</li>

<li>AutoLISP<br />
<a href="https://en.wikipedia.org/wiki/AutoLISP">https://en.wikipedia.org/wiki/AutoLISP</a>
</li>

<li>Seriál PicoLisp: minimalistický a výkonný interpret Lispu<br />
<a href="https://www.root.cz/serialy/picolisp-minimalisticky-a-vykonny-interpret-lispu/">https://www.root.cz/serialy/picolisp-minimalisticky-a-vykonny-interpret-lispu/</a>
</li>

<li>Common Lisp<br />
<a href="https://common-lisp.net/">https://common-lisp.net/</a>
</li>

<li>Getting Going with Common Lisp<br />
<a href="https://cliki.net/Getting%20Started">https://cliki.net/Getting%20Started</a>
</li>

<li>Online Tutorial (Common Lisp)<br />
<a href="https://cliki.net/online%20tutorial">https://cliki.net/online%20tutorial</a>
</li>

<li>Guile Emacs<br />
<a href="https://www.emacswiki.org/emacs/GuileEmacs">https://www.emacswiki.org/emacs/GuileEmacs</a>
</li>

<li>Guile Emacs History<br />
<a href="https://www.emacswiki.org/emacs/GuileEmacsHistory">https://www.emacswiki.org/emacs/GuileEmacsHistory</a>
</li>

<li>Guile is a programming language<br />
<a href="https://www.gnu.org/software/guile/">https://www.gnu.org/software/guile/</a>
</li>

<li>MIT Scheme<br />
<a href="http://groups.csail.mit.edu/mac/projects/scheme/">http://groups.csail.mit.edu/mac/projects/scheme/</a>
</li>

<li>SIOD: Scheme in One Defun<br />
<a href="http://people.delphiforums.com/gjc//siod.html">http://people.delphiforums.com/gjc//siod.html</a>
</li>

<li>CommonLispForEmacs<br />
<a href="https://www.emacswiki.org/emacs/CommonLispForEmacs">https://www.emacswiki.org/emacs/CommonLispForEmacs</a>
</li>

<li>Elisp: print, princ, prin1, format, message<br />
<a href="http://ergoemacs.org/emacs/elisp_printing.html">http://ergoemacs.org/emacs/elisp_printing.html</a>
</li>

<li>Special Forms in Lisp<br />
<a href="http://www.nhplace.com/kent/Papers/Special-Forms.html">http://www.nhplace.com/kent/Papers/Special-Forms.html</a>
</li>

<li>Basic Building Blocks in LISP<br />
<a href="https://www.tutorialspoint.com/lisp/lisp_basic_syntax.htm">https://www.tutorialspoint.com/lisp/lisp_basic_syntax.htm</a>
</li>

<li>Introduction to LISP - University of Pittsburgh<br />
<a href="https://people.cs.pitt.edu/~milos/courses/cs2740/Lectures/LispTutorial.pdf">https://people.cs.pitt.edu/~milos/courses/cs2740/Lectures/LispTutorial.pdf</a>
</li>

<li>Why don't people use LISP<br />
<a href="https://forums.freebsd.org/threads/why-dont-people-use-lisp.24572/">https://forums.freebsd.org/threads/why-dont-people-use-lisp.24572/</a>
</li>

<li>Structured program theorem<br />
<a href="https://en.wikipedia.org/wiki/Structured_program_theorem">https://en.wikipedia.org/wiki/Structured_program_theorem</a>
</li>

<li>Clojure: API Documentation<br />
<a href="https://clojure.org/api/api">https://clojure.org/api/api</a>
</li>

<li>Tutorial for the Common Lisp Loop Macro<br />
<a href="http://www.ai.sri.com/pkarp/loop.html">http://www.ai.sri.com/pkarp/loop.html</a>
</li>

<li>Common Lisp's Loop Macro Examples for Beginners<br />
<a href="http://www.unixuser.org/~euske/doc/cl/loop.html">http://www.unixuser.org/~euske/doc/cl/loop.html</a>
</li>

<li>A modern list api for Emacs. No 'cl required.<br />
<a href="https://github.com/magnars/dash.el">https://github.com/magnars/dash.el</a>
</li>

<li>The LOOP Facility<br />
<a href="http://www.lispworks.com/documentation/HyperSpec/Body/06_a.htm">http://www.lispworks.com/documentation/HyperSpec/Body/06_a.htm</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>Transient Data Structures
<a href="http://clojure.org/transients">http://clojure.org/transients</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Clojure (na Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (na Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>SICP (The Structure and Interpretation of Computer Programs)<br />
<a href="http://mitpress.mit.edu/sicp/">http://mitpress.mit.edu/sicp/</a>
</li>

<li>Pure function<br />
<a href="http://en.wikipedia.org/wiki/Pure_function">http://en.wikipedia.org/wiki/Pure_function</a>
</li>

<li>Funkcionální programování<br />
<a href="http://cs.wikipedia.org/wiki/Funkcionální_programování">http://cs.wikipedia.org/wiki/Funkcionální_programování</a>
</li>

<li>Jazyky Hy a Clojure-py: moderní dialekty LISPu určené pro Python VM<br />
<a href="https://www.root.cz/clanky/jazyky-hy-a-clojure-py-moderni-dialekty-lispu-urcene-pro-python-vm/">https://www.root.cz/clanky/jazyky-hy-a-clojure-py-moderni-dialekty-lispu-urcene-pro-python-vm/</a>
</li>

<li>Pixie: lehký skriptovací jazyk s „kouzelnými“ schopnostmi<br />
<a href="https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/">https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/</a>
</li>

<li>Programovací jazyk Pixie: funkce ze základní knihovny a použití FFI<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/">https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/</a>
</li>

<li>Stránka projektu Jython<br />
<a href="http://www.jython.org/">http://www.jython.org/</a>
</li>

<li>Jython (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Jython">https://en.wikipedia.org/wiki/Jython</a>
</li>

<li>Scripting for the Java Platform (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform">https://en.wikipedia.org/wiki/Scripting_for_the_Java_Platform</a>
</li>

<li>JSR 223: Scripting for the Java<sup>TM</sup> Platform<br />
<a href="https://jcp.org/en/jsr/detail?id=223">https://jcp.org/en/jsr/detail?id=223</a>
</li>

<li>List of JVM languages<br />
<a href="https://en.wikipedia.org/wiki/List_of_JVM_languages">https://en.wikipedia.org/wiki/List_of_JVM_languages</a>
</li>

<li>The Java<sup>TM</sup> Virtual Machine Specification, Second Edition<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html</a>
</li>

<li>The class File Format<br />
<a href="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html">http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html</a>
</li>

<li>javap - The Java Class File Disassembler<br />
<a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html">http://docs.oracle.com/javase/1.4.2/docs/tooldocs/windows/javap.html</a>
</li>

<li>javap-java-1.6.0-openjdk(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/javap-java-1.6.0-openjdk">http://linux.die.net/man/1/javap-java-1.6.0-openjdk</a>
</li>

<li>Using javap<br />
<a href="http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html">http://www.idevelopment.info/data/Programming/java/miscellaneous_java/Using_javap.html</a>
</li>

<li>Examine class files with the javap command<br />
<a href="http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354">http://www.techrepublic.com/article/examine-class-files-with-the-javap-command/5815354</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

